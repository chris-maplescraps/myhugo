{"categories":[{"link":"/categories/life/","name":"Life","slug":"Life"},{"link":"/categories/tech/","name":"Tech","slug":"Tech"},{"link":"/categories/%E5%8D%9A%E5%AE%A2/","name":"博客","slug":"博客"}],"pages":[],"posts":[{"link":"/posts/156ed8d/","text":"Rich_lib Rich 是一个在终端渲染“富文本”的 Python 库：颜色、样式、表格、进度条、Markdown、代码高亮、异常栈（traceback）等都能优雅呈现，且上手简单。\n本文提炼核心概念、为什么好用、底层如何实现，以及常用场景的简明示例，帮助你在命令行工具、服务日志、调试打印中快速落地。\n一句话总结 用 rich.print 或 Console().print 替代内置 print，即可获得着色、换行与对齐、结构化美化等能力。 通过“可渲染对象（renderable）”与“标记语法（markup）”组合，轻松构建表格、进度条、Markdown、代码高亮、异常栈输出。 为什么选 Rich（核心价值） 输出更可读：自动换行、对齐，复杂结构（列表/字典）美化显示。 调试更高效：inspect、着色的 traceback、带时间与文件位置的 log。 交互更优雅：表格、进度条、状态显示、Emoji 等改善 CLI 体验。 易集成：API 贴近 print；无侵入接入 logging；Jupyter 直接支持。 核心技术与实现原理（通俗解释） ANSI 转义序列与 Unicode 符号：颜色/样式通过 ANSI 码实现，表格边框等用 Unicode 绘制。 终端宽度测量与布局：Console 会测量终端宽度，自动折行、对齐，保证输出不“炸行”。 可渲染协议：内置与自定义的“可渲染对象”（如 Table、Panel、Markdown）实现统一的渲染接口，交给 Console 输出。 标记语法（markup）：类似 BBCode 的标签（如 [bold red]...[/]）在渲染前被解析为样式指令，而非字符串本身的一部分。 语法高亮与异常美化：对源代码和异常栈进行词法解析/着色，使调试信息更易读。 Windows 兼容：新版 Windows Terminal 支持真彩与 Emoji；经典终端颜色较少，但核心功能仍可用。 快速开始 BASH\rCollapse\rCopy\rpython -m pip install rich\rClick to expand and view more\r最简使用：\nPYTHON\rCollapse\rCopy\rfrom rich import print print(\u0026#34;Hello, [bold magenta]World[/bold magenta]!\u0026#34;)\rClick to expand and view more\r更可控的控制台：\nPYTHON\rCollapse\rCopy\rfrom rich.console import Console console = Console() console.print(\u0026#34;Hello\u0026#34;, \u0026#34;World!\u0026#34;, style=\u0026#34;bold red\u0026#34;)\rClick to expand and view more\r在 REPL 美化所有对象：\nPYTHON\rCollapse\rCopy\rfrom rich import pretty pretty.install()\rClick to expand and view more\r常用能力与示例 着色与样式（style 与 markup） PYTHON\rCollapse\rCopy\rfrom rich import print print(\u0026#34;错误: [bold red]连接失败[/]，请稍后重试\u0026#34;)\rClick to expand and view more\rstyle 关键字对整段生效；markup 可在文本内局部着色。 常见样式：bold italic underline，颜色可用 red/green/blue 或 #RRGGBB。 表格（Table） PYTHON\rCollapse\rCopy\rfrom rich.table import Table from rich.console import Console console = Console() table = Table(title=\u0026#34;服务状态\u0026#34;) table.add_column(\u0026#34;服务\u0026#34;, style=\u0026#34;cyan\u0026#34;, no_wrap=True) table.add_column(\u0026#34;状态\u0026#34;, style=\u0026#34;green\u0026#34;) table.add_column(\u0026#34;耗时(ms)\u0026#34;, justify=\u0026#34;right\u0026#34;) for name, ok, ms in [(\u0026#34;auth\u0026#34;, True, 32), (\u0026#34;api\u0026#34;, False, 215)]: table.add_row(name, \u0026#34;✅\u0026#34; if ok else \u0026#34;❌\u0026#34;, str(ms)) console.print(table)\rClick to expand and view more\r进度条（Progress） PYTHON\rCollapse\rCopy\rfrom time import sleep from rich.progress import Progress with Progress() as progress: task = progress.add_task(\u0026#34;下载中\u0026#34;, total=100) for _ in range(100): sleep(0.02) progress.update(task, advance=1)\rClick to expand and view more\rMarkdown 渲染 PYTHON\rCollapse\rCopy\rfrom rich.console import Console from rich.markdown import Markdown md = Markdown(\u0026#34;\u0026#34;\u0026#34; # 标题 - 支持列表 - 支持代码块 \u0026#34;\u0026#34;\u0026#34;) Console().print(md)\rClick to expand and view more\r代码高亮（Syntax） PYTHON\rCollapse\rCopy\rfrom rich.syntax import Syntax code = \u0026#34;print(\u0026#39;hello rich\u0026#39;)\\nfor i in range(3): print(i)\u0026#34; Console().print(Syntax(code, \u0026#34;python\u0026#34;, theme=\u0026#34;monokai\u0026#34;, line_numbers=True))\rClick to expand and view more\r异常栈美化（Traceback） PYTHON\rCollapse\rCopy\rfrom rich.traceback import install install(show_locals=True) # 启用后，异常会以彩色、结构化形式显示 # 然后正常写代码，抛异常时自动美化输出\rClick to expand and view more\r调试对象（inspect） PYTHON\rCollapse\rCopy\rfrom rich import inspect obj = {\u0026#34;user\u0026#34;: \u0026#34;alice\u0026#34;, \u0026#34;roles\u0026#34;: [\u0026#34;admin\u0026#34;, \u0026#34;ops\u0026#34;]} inspect(obj, methods=True)\rClick to expand and view more\r日志美化与 logging 集成 PYTHON\rCollapse\rCopy\rimport logging from rich.logging import RichHandler logging.basicConfig( level=\u0026#34;INFO\u0026#34;, format=\u0026#34;%(message)s\u0026#34;, datefmt=\u0026#34;%H:%M:%S\u0026#34;, handlers=[RichHandler()] # 直接替换默认 handler ) log = logging.getLogger(\u0026#34;svc\u0026#34;) log.info({\u0026#34;event\u0026#34;: \u0026#34;started\u0026#34;, \u0026#34;port\u0026#34;: 8080})\rClick to expand and view more\rEmoji（适度使用） PYTHON\rCollapse\rCopy\rfrom rich.console import Console Console().print(\u0026#34;:rocket: 部署完成！\u0026#34;)\rClick to expand and view more\r实战建议（工程化落地） 封装统一输出：在 CLI 或服务中创建全局 Console，集中管控样式/日志。 分层使用：结构化数据用 inspect/表格；人机提示用着色文本；过程用进度条。 与 logging 融合：生产环境保留结构化日志（JSON），本地/交付版加 Rich 美化，兼顾机器可读与人类可读。 终端兼容：在非 TTY 或日志重定向场景关闭颜色（Console(color_system=None) 或根据环境检测）。 标记语法规范：成对关闭标签（[/]），避免嵌套过多影响可读性。 容易踩雷 经典 Windows 终端颜色有限：若需真彩与 Emoji，使用 Windows Terminal。 宽表格/长行输出：终端宽度有限，尽量设置 no_wrap 与 justify，或拆分输出。 进度条在非交互环境：CI 日志可能乱；可在检测到非 TTY 时禁用。 颜色重定向：将输出重定向到文件时，ANSI 码会“脏”；需关闭颜色或在查看器中支持 ANSI。 一屏速查（关键词） 控制台：Console().print style=\u0026quot;bold red\u0026quot; markup 表格：Table(title) add_column add_row justify no_wrap 进度：Progress.add_task update(advance=...) Markdown：Markdown(text) 代码高亮：Syntax(code, \u0026quot;python\u0026quot;) 异常：traceback.install(show_locals=True) 调试：inspect(obj, methods=True) 日志：RichHandler() logging.basicConfig(handlers=[...]) Emoji：\u0026quot;:smiley:\u0026quot; \u0026quot;:rocket:\u0026quot; 参考 Rich 官方 README（简体中文）：https://github.com/textualize/rich/blob/master/README.cn.md ","title":"Rich"},{"link":"/posts/linux-shell/","text":"Linux Shell 核心命令速查（运维/DevOps） 这份速查把“日常必用”命令按场景分组，配最短解释与最小例子，一屏掌握、拿来即用。\n1. 文件与目录 查看与导航： BASH\rCollapse\rCopy\rpwd # 显示当前目录 ls -la # 列出详细文件（含隐藏） cd /var/log # 切换目录\rClick to expand and view more\r查找： BASH\rCollapse\rCopy\rfind /var/log -name \u0026#34;*.log\u0026#34; # 按文件名查找 grep -R \u0026#34;ERROR\u0026#34; /var/log # 递归搜索文本\rClick to expand and view more\r创建与移动： BASH\rCollapse\rCopy\rmkdir -p /data/app/logs # 递归创建目录 cp app.conf /etc/app/ # 复制文件 mv old.log logs/ # 移动/重命名 rm -rf tmp/ # 删除目录（危险！确认路径）\rClick to expand and view more\r2. 文本查看与处理 快速查看： BASH\rCollapse\rCopy\rcat file.log # 显示全文（小文件） less file.log # 分页查看（q退出） head -n 50 file.log # 前 50 行 tail -n 100 file.log # 后 100 行 tail -f app.log # 实时追踪日志\rClick to expand and view more\r查找筛选： BASH\rCollapse\rCopy\rgrep -n \u0026#34;ERROR\u0026#34; app.log # 搜索并显示行号 grep -R \u0026#34;timeout\u0026#34; . # 递归搜索当前目录\rClick to expand and view more\r统计与去重： BASH\rCollapse\rCopy\rwc -l app.log # 行数 sort app.log | uniq -c | sort -nr # 频次统计\rClick to expand and view more\rawk/sed（最常用场景）： BASH\rCollapse\rCopy\rawk -F\u0026#39;,\u0026#39; \u0026#39;{print $1,$3}\u0026#39; data.csv # 选取列 sed -n \u0026#39;100,120p\u0026#39; app.log # 打印指定行范围 sed -i \u0026#39;s/DEBUG/INFO/g\u0026#39; app.conf # 就地替换（谨慎）\rClick to expand and view more\r3. 进程与服务 进程查看： BASH\rCollapse\rCopy\rps aux | grep app # 查进程 top # 实时监控（htop更好用） pgrep -f \u0026#34;gunicorn\u0026#34; # 找到进程ID\rClick to expand and view more\r终止与优先级： BASH\rCollapse\rCopy\rkill -9 \u0026lt;pid\u0026gt; # 强制杀进程（优先尝试不带 -9） renice 10 -p \u0026lt;pid\u0026gt; # 调整优先级\rClick to expand and view more\rsystemd（常见）： BASH\rCollapse\rCopy\rsudo systemctl status app.service # 查看状态 sudo systemctl restart app.service # 重启服务 journalctl -u app.service -f # 实时查看 Unit 日志\rClick to expand and view more\r4. 网络与连通性 基本连通： BASH\rCollapse\rCopy\rping 8.8.8.8 # 测试网络 curl -I https://example.com # 查看响应头 wget https://example.com/file # 下载文件\rClick to expand and view more\r端口与连接： BASH\rCollapse\rCopy\rss -tulpn # 查看监听端口 lsof -i :8080 # 查看占用端口的进程 nc -vz host 80 # 测试端口（TCP）\rClick to expand and view more\rDNS 与路由： BASH\rCollapse\rCopy\rdig example.com +short # 查询 DNS traceroute example.com # 路由追踪\rClick to expand and view more\r5. 磁盘与文件系统 使用情况： BASH\rCollapse\rCopy\rdf -h # 磁盘占用（人类可读） du -sh /var/log # 目录大小汇总 du -h --max-depth=1 /data # 一级目录大小\rClick to expand and view more\r分区与设备： BASH\rCollapse\rCopy\rlsblk # 查看块设备\rClick to expand and view more\r6. 压缩与打包 BASH\rCollapse\rCopy\rtar -czf logs.tar.gz logs/ # 打包压缩目录 tar -xzf logs.tar.gz # 解压 zip -r site.zip public/ # zip 压缩 unzip site.zip # 解压\rClick to expand and view more\r7. 权限与所有者 BASH\rCollapse\rCopy\rchmod 644 file.conf # 读写权限（所有者可写，其他只读） chmod -R 755 /usr/local/bin # 递归设置可执行 chown root:root /etc/app.conf # 变更所有者和组\rClick to expand and view more\r8. 包管理（按发行版） Debian/Ubuntu： BASH\rCollapse\rCopy\rsudo apt update \u0026amp;\u0026amp; sudo apt install htop apt list --installed | grep nginx\rClick to expand and view more\rCentOS/RHEL（Dnf/Yum）： BASH\rCollapse\rCopy\rsudo dnf install htop # 或 yum sudo dnf list installed | grep nginx\rClick to expand and view more\r9. 日志与系统信息 BASH\rCollapse\rCopy\rjournalctl -xe # 最近错误详情 journalctl --since \u0026#34;-2h\u0026#34; # 最近2小时日志 dmesg | tail # 内核消息（启动/设备） uname -a # 内核与系统信息 cat /etc/os-release # 发行版信息\rClick to expand and view more\r10. SSH 与文件传输 BASH\rCollapse\rCopy\rssh user@host # 远程登录 ssh -i ~/.ssh/id_rsa user@host # 指定密钥 scp file user@host:/path/ # 传文件 rsync -avz dir/ user@host:/path/ # 同步目录 ssh-keygen -t ed25519 # 生成密钥 ssh-copy-id user@host # 上传公钥\rClick to expand and view more\r11. Docker 核心 BASH\rCollapse\rCopy\rdocker ps # 列出容器 docker logs -f \u0026lt;container\u0026gt; # 跟踪日志 docker exec -it \u0026lt;container\u0026gt; sh # 进入容器 docker inspect \u0026lt;container\u0026gt; # 查看细节 docker run -d -p 8080:80 nginx # 快速启动 docker stop \u0026lt;container\u0026gt;; docker rm \u0026lt;container\u0026gt; # 停止并删除\rClick to expand and view more\r12. Kubernetes（kubectl）核心 BASH\rCollapse\rCopy\rkubectl get pods -n prod # 查看Pod kubectl describe pod \u0026lt;name\u0026gt; -n prod # 详情 kubectl logs -f \u0026lt;pod\u0026gt; -n prod # 日志 kubectl exec -it \u0026lt;pod\u0026gt; -- sh -n prod # 进入容器 kubectl rollout restart deploy/\u0026lt;name\u0026gt; -n prod # 重启部署 kubectl scale deploy/\u0026lt;name\u0026gt; --replicas=3 -n prod # 扩容 kubectl port-forward svc/\u0026lt;name\u0026gt; 8080:80 -n prod # 本地转发 kubectl apply -f manifest.yaml # 应用配置 kubectl delete -f manifest.yaml # 删除资源\rClick to expand and view more\r13. 定时与监控（简单版） BASH\rCollapse\rCopy\rcrontab -e # 编辑定时任务 crontab -l # 查看定时任务 free -h # 内存 vmstat 1 5 # 虚拟内存/上下文切换 sar -n DEV 1 5 # 网络设备统计（需 sysstat）\rClick to expand and view more\r14. 容易踩雷（务必注意） rm -rf 路径确认三遍，慎用变量拼接；可先用 echo 打印再执行。 sed -i 就地修改前先备份；生产环境建议走配置模板+回滚机制。 kill -9 是最后手段，优先尝试普通 kill 给程序机会清理资源。 journalctl 带时间窗口（如 --since/--until）更高效，避免一次性吐出海量日志。 ss/lsof 权限不足时用 sudo；避免误判端口占用。 Docker 与宿主机时区/时钟差异会影响日志和定时，统一时区配置。 Kubernetes 资源改动优先 kubectl apply + GitOps/CI 管控，避免直接编辑线上对象。 15. 一屏速查关键词 文件：ls cd pwd find grep -R mkdir cp mv rm -rf 文本：head tail -f less awk sed wc sort | uniq -c 进程：ps top pgrep kill renice systemctl journalctl 网络：ping curl -I ss -tulpn lsof -i :PORT nc -vz dig 磁盘：df -h du -sh lsblk 压缩：tar -czf tar -xzf zip unzip 权限：chmod chown 包：apt dnf 传输：ssh scp rsync ssh-keygen ssh-copy-id 容器：docker ps logs -f exec -it run -d -p stop rm K8s：kubectl get/describe/logs/exec/rollout/scale/port-forward/apply/delete 如果你希望我再加：\n高级 awk/sed 模板、正则技巧 systemd 定时器与健康检查（service + timer） docker compose 与镜像构建 cache/多阶段 kubectl 上下文/多集群管理与 k9s 告诉我我就补上。 ","title":"Linux Shell 核心命令速查"},{"link":"/posts/uvx-project/","text":"UVX Project 这篇用最简单的话，手把手说明：用 uv 管理 Python 项目与依赖，用 uvx 运行工具和打包；怎样初始化项目、创建并激活虚拟环境、安装第三方库、打包分发给团队，以及团队如何快速安装。\n重要区分：\nuv：项目依赖管理/安装/运行（替代 pip、加速安装），还能自动创建本地虚拟环境（.venv）。 uvx：像 pipx 一样“隔离运行工具”，也可直接调用打包工具。 1. 用 uv init 初始化最简项目 在新目录中初始化： BASH\rCollapse\rCopy\rmkdir myproj \u0026amp;\u0026amp; cd myproj uv init\rClick to expand and view more\ruv init 会生成最小的 pyproject.toml（PEP 621），你可按需修改项目名、作者、Python 版本等。 补充推荐的 src 布局与示例代码： PLAINTEXT\rCollapse\rCopy\rsrc/\rmyproj/\r__init__.py\rapp.py\rtests/\rtest_app.py\rClick to expand and view more\r示例代码： PYTHON\rCollapse\rCopy\r# src/myproj/app.py def hello(name: str) -\u0026gt; str: return f\u0026#34;Hello, {name}!\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: print(hello(\u0026#34;World\u0026#34;))\rClick to expand and view more\r创建并安装依赖与虚拟环境： BASH\rCollapse\rCopy\ruv sync\rClick to expand and view more\r运行代码： BASH\rCollapse\rCopy\ruv run python src/myproj/app.py\rClick to expand and view more\r2. 创建与激活虚拟环境（两种方式） 用 uv 自动管理（推荐）： 在项目根执行 uv sync，uv 会自动创建本地虚拟环境 .venv 并安装依赖。 运行代码时无需手动激活： BASH\rCollapse\rCopy\ruv sync uv run python src/myproj/app.py\rClick to expand and view more\r手动创建与激活（标准 venv）： 创建：python -m venv .venv 激活： Windows（PowerShell）：./.venv/Scripts/Activate.ps1 Windows（cmd）：\\.venv\\Scripts\\activate macOS/Linux（bash/zsh）：source .venv/bin/activate 退出：deactivate 激活后安装依赖可用： BASH\rCollapse\rCopy\ruv pip install -r requirements.txt # 或 uv add/sync\rClick to expand and view more\r3. 安装第三方库（用 uv 管理依赖） 安装 uv（见《UVX》文档）并确认：uv --version。 在项目根目录执行： BASH\rCollapse\rCopy\r# 添加运行时依赖（写入 pyproject.toml 并安装） uv add requests # 添加开发依赖（只在开发/测试用） uv add -D ruff black pytest # 安装/同步所有依赖（根据 pyproject 与锁定文件） uv sync\rClick to expand and view more\r运行代码（不污染系统环境）： BASH\rCollapse\rCopy\ruv run python src/myproj/app.py\rClick to expand and view more\r4. 使用 uvx 运行工具（不改动项目依赖） 隔离运行常用工具（首次会解析并缓存）： BASH\rCollapse\rCopy\ruvx ruff --version uvx black --help uvx pyright --version\rClick to expand and view more\r指定 Python 版本运行： BASH\rCollapse\rCopy\ruvx --python 3.12 ruff --version\rClick to expand and view more\r从 URL/Git/本地路径来源运行某工具： BASH\rCollapse\rCopy\ruvx --from https://github.com/httpie/cli http --version uvx --from ./ some-local-cli\rClick to expand and view more\r5. 打包项目（生成 sdist 和 wheel） 最简单方法：用 build 工具（通过 uvx 运行）： BASH\rCollapse\rCopy\ruvx build # 产物在 dist/ 目录： .tar.gz（sdist）和 .whl（wheel）\rClick to expand and view more\r如需发布到 PyPI，可结合 twine： BASH\rCollapse\rCopy\ruvx twine upload dist/*\rClick to expand and view more\r6. 团队协作：如何快速安装项目依赖 方式 A（推荐，用 uv）： BASH\rCollapse\rCopy\r# 团队成员安装 uv 后，在项目根目录执行： uv sync # 一次性安装 pyproject.toml 声明的所有依赖（含锁定版本）\rClick to expand and view more\r方式 B（requirements.txt 方案）： BASH\rCollapse\rCopy\r# 维护 requirements.txt 后，团队成员可执行： uv pip install -r requirements.txt\rClick to expand and view more\r项目本地可编辑安装（开发场景）： BASH\rCollapse\rCopy\ruv pip install -e .\rClick to expand and view more\r7. 最常用命令速查（一屏足够） 虚拟环境：uv sync 自动创建/使用 .venv；或 python -m venv .venv + 激活。 依赖管理： 添加运行时依赖：uv add \u0026lt;pkg\u0026gt; 添加开发依赖：uv add -D \u0026lt;pkg\u0026gt; 安装/同步：uv sync 运行代码：uv run python \u0026lt;script\u0026gt; 运行工具（隔离）：uvx \u0026lt;tool\u0026gt; [args] 指定版本/来源： uvx \u0026quot;tool==x.y\u0026quot;、uvx --python 3.12 \u0026lt;tool\u0026gt; uvx --from \u0026lt;url|git|path\u0026gt; \u0026lt;tool\u0026gt; 打包：uvx build（产物在 dist/） 发布：uvx twine upload dist/* 8. 容易踩雷的地方（简明版） 混用 pip 与 uv：尽量统一用 uv 管理，避免环境不一致。 PATH 未生效：安装后终端不识别 uv/uvx，重启终端或手动加 PATH。 Python 版本不匹配：用 uvx --python X.Y 明确工具的运行版本。 锁定版本一致性：团队应共享锁定文件（如 uv.lock），用 uv sync 安装确保一致。 打包失败：检查 pyproject.toml 的 [build-system] 是否配置正确；源代码需可被发现（src 布局、包名对应）。 入口点名称：运行的是工具的入口点，不一定与包名相同（如 httpie 的命令是 http）。 9. 一个从零到发布的最小流程 BASH\rCollapse\rCopy\r# 1) 创建结构并写 pyproject.toml # 2) 管理依赖 uv add requests uv add -D ruff black pytest uv sync # 3) 开发与检查 uv run python src/myproj/app.py uvx ruff check . uvx black . pytest # 或 uvx pytest # 4) 打包与发布 uvx build uvx twine upload dist/*\rClick to expand and view more\r","title":"UVX Project"},{"link":"/posts/4e762c2/","text":"UVX 用最简单的话说：uvx 是一个“像 pipx 一样运行 Python 包内应用”的命令，来自超快的包管理器 uv。它帮你无需污染系统或项目环境，就能直接运行包提供的命令行工具（如 ruff、httpie、black、jupyter 等），并复用缓存、速度极快。\n快速安装与配置（跨平台） Windows（PowerShell）： POWERSHELL\rCollapse\rCopy\riwr -useb https://astral.sh/uv/install.ps1 | iex\rClick to expand and view more\rmacOS/Linux（sh）： BASH\rCollapse\rCopy\rcurl -LsSf https://astral.sh/uv/install.sh | sh # 或 wget -qO- https://astral.sh/uv/install.sh | sh\rClick to expand and view more\r验证安装： BASH\rCollapse\rCopy\ruv --version uvx --help\rClick to expand and view more\rPATH：安装脚本会自动配置；若终端尚未识别，关闭并重新打开终端，或手动将安装目录加入 PATH。 一句话认识 uvx 目的：隔离地运行“Python 包的可执行入口（console script）”。 原理：解析包的入口点，创建/复用隔离环境（缓存），执行工具，不影响系统或项目依赖。 场景：试用工具、CI/CD 任务、统一团队工具版本、避免全局 pip 安装。 常用命令（最常用 5 条） BASH\rCollapse\rCopy\r# 1) 直接运行某个包提供的命令（首次会解析并缓存） uvx ruff --version uvx http --help # httpie # 2) 指定 Python 版本（与系统 Python 解耦） uvx --python 3.12 ruff --version # 3) 指定来源（URL/VCS/本地路径），适合试用未发布版本 uvx --from https://github.com/astral-sh/ruff ruff --version uvx --from ./local-package-dir some-cli # 4) 指定精确包版本/额外依赖（extras） uvx \u0026#34;black==24.10.0\u0026#34; --version uvx \u0026#34;mytool[cli]\u0026#34; --help # 5) 查看帮助与入口点解析 uvx --help\rClick to expand and view more\r核心技术点（理解就够了） 入口点：读取包的 console_scripts 定义，解析到具体可执行名。 解析与缓存：uv 的求解器极速解析依赖，结果缓存到本地，下次复用。 隔离执行：在独立环境中运行，不写入系统 Python 或项目虚拟环境。 多版本 Python：可用 --python X.Y 明确运行时版本，避免“系统 Python 版本不匹配”。 高频场景 临时使用开发工具：uvx ruff、uvx black、uvx pyright、uvx http。 固定版本运行：uvx \u0026quot;ruff==0.6.9\u0026quot; 保证团队统一版本。 在 CI 里跑任务：不预装依赖，直接 uvx \u0026lt;tool\u0026gt;。 运行未发布/开发版：uvx --from git+https://... \u0026lt;cmd\u0026gt;。 容易踩雷（简明版） PATH 未生效：安装后终端不识别 uv/uvx，重启终端或手动加 PATH。 命令名与包名不一致：运行的是“入口点名称”，不是总是包名；用 uvx \u0026lt;入口点\u0026gt;。 版本没变的错觉：缓存会复用旧版本；需要指定版本号（如 pkg==x.y）以确保一致。 私有源访问：需按 uv 的用法指定源（如 --index-url）；否则默认用 PyPI。 网络/代理：公司网络限制可能导致解析失败，配置代理或镜像源。 与项目 venv 混淆：uvx 不依赖你当前 venv；如果工具读取项目依赖，请明确路径或在项目 venv 内运行对应命令。 速查清单 运行：uvx \u0026lt;cmd\u0026gt;、uvx \u0026lt;pkg\u0026gt; [args] 指定 Python：uvx --python 3.11 \u0026lt;cmd\u0026gt; 指定来源：uvx --from \u0026lt;url|git|path\u0026gt; \u0026lt;cmd\u0026gt; 指定版本：uvx \u0026quot;pkg==x.y\u0026quot; \u0026lt;cmd\u0026gt; Extras：uvx \u0026quot;pkg[extra]\u0026quot; 帮助：uvx --help 小示例 BASH\rCollapse\rCopy\r# 1) 一次性运行代码格式化 uvx black . # 2) 固定版本的 lint uvx \u0026#34;ruff==0.6.9\u0026#34; check . # 3) 试用开发版 httpie uvx --from https://github.com/httpie/cli http --version # 4) 指定 Python 版本运行 jupyter uvx --python 3.12 jupyter lab\rClick to expand and view more\r如果你希望把这篇文章发布到站点主页列表页，目前已是 draft = false，无需额外操作。如需我添加“代理/私有源配置速查”或“常见工具合集（ruff、black、pytest、pyright、httpie）”，我可以继续补充。\n","title":"UVX"},{"link":"/posts/2346b59/","text":"Vs Configuration ","title":"VS Configuration"},{"link":"/posts/86b4563/","text":"Float 这篇用最简单的话，讲清 Python 浮点数（float）：它用来表示带小数的数字，但不是所有小数都能“精确”表示，因此比较和计算要有正确姿势。\n一句话认识 float float 是带小数的数字类型，比如 1.5、0.1。 不是所有十进制小数都能精确表示（比如 0.1），所以有“微小误差”。 有三个特殊值：inf（正无穷）、-inf（负无穷）、nan（不是一个数）。 为什么 0.1 + 0.2 不等于 0.3？ 因为 0.1 和 0.2 在二进制里是“无限循环”的近似数，计算后会带一点点误差。 PYTHON\rCollapse\rCopy\r0.1 + 0.2 == 0.3 # False\rClick to expand and view more\r正确比较方式：用“差不多就算相等”的判断。 PYTHON\rCollapse\rCopy\rimport math math.isclose(0.1 + 0.2, 0.3, rel_tol=1e-9, abs_tol=0.0) # True\rClick to expand and view more\r常用操作（够用版） 四舍五入（注意：Python 的 round 是“银行家舍入”，.5 会向偶数靠拢）： PYTHON\rCollapse\rCopy\rround(2.5) # 2 round(3.5) # 4 round(1.2345, 2) # 1.23\rClick to expand and view more\r特殊值判断： PYTHON\rCollapse\rCopy\rimport math math.isfinite(x) # x 是否有限（不是 inf/-inf/nan） math.isinf(x) # 是否无穷 math.isnan(x) # 是否 NaN（不是一个数）\rClick to expand and view more\r格式化输出（控制显示样式）： PYTHON\rCollapse\rCopy\rn = 1234.56789 f\u0026#34;{n:.2f}\u0026#34; # \u0026#39;1234.57\u0026#39; 保留两位小数 f\u0026#34;{n:e}\u0026#34; # \u0026#39;1.234568e+03\u0026#39; 科学计数法 format(n, \u0026#34;,.2f\u0026#34;) # \u0026#39;1,234.57\u0026#39; 千分位\rClick to expand and view more\r计算里的小技巧 大量求和更稳： PYTHON\rCollapse\rCopy\rimport math math.fsum([1e100, 1, -1e100]) # 比 sum 更稳定\rClick to expand and view more\r比较相等尽量用近似： PYTHON\rCollapse\rCopy\rmath.isclose(a, b, rel_tol=1e-9, abs_tol=1e-12)\rClick to expand and view more\rDecimal（金额等需要“真的精确”） 如果场景需要十进制“严格精确”（比如金额），用 decimal.Decimal。 关键点：从“字符串”创建，别直接把 float 丢进去。 PYTHON\rCollapse\rCopy\rfrom decimal import Decimal, ROUND_HALF_UP Decimal(\u0026#39;0.1\u0026#39;) + Decimal(\u0026#39;0.2\u0026#39;) == Decimal(\u0026#39;0.3\u0026#39;) # True（精确） Decimal(0.1) # 不精确（带入了 float 的误差） # 金额常用四舍五入 amount = Decimal(\u0026#39;2.345\u0026#39;) amount.quantize(Decimal(\u0026#39;0.01\u0026#39;), rounding=ROUND_HALF_UP) # 2.35\rClick to expand and view more\rFraction（分数要精确） 需要精确分数计算时用 fractions.Fraction。 PYTHON\rCollapse\rCopy\rfrom fractions import Fraction Fraction(1, 3) + Fraction(1, 6) # Fraction(1, 2)\rClick to expand and view more\r容易踩雷（简明版） 0.1 + 0.2 != 0.3：用 math.isclose 比较。 round 的 .5 不是总向上：是“银行家舍入”（向偶数）。 Decimal 要用字符串创建：Decimal('1.23')，不要 Decimal(1.23)。 nan 的比较永远不相等：用 math.isnan(x) 判断。 文本转浮点要先清洗：float('1,234.5') 会报错（逗号）。 负零展示问题：-0.0 == 0.0，但显示可能带“-”，格式化时留意。 Decimal 和 float 不要混着算：会退化为 float，丢精度。 速查清单 近似比较：math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0) 判断状态：math.isfinite(x) / math.isinf(x) / math.isnan(x) 稳定求和：math.fsum(iterable) 四舍五入：round(x, n)（.5 向偶数） 格式化：f\u0026quot;{x:.2f}\u0026quot;、f\u0026quot;{x:e}\u0026quot;、format(x, ',.2f') 精确金额：Decimal('...') + quantize(..., ROUND_HALF_UP) 小示例 PYTHON\rCollapse\rCopy\rimport math print(math.isclose(0.1 + 0.2, 0.3)) # True # 金额四舍五入 from decimal import Decimal, ROUND_HALF_UP print(Decimal(\u0026#39;2.345\u0026#39;).quantize(Decimal(\u0026#39;0.01\u0026#39;), rounding=ROUND_HALF_UP)) # 2.35 # 显示两位小数 x = 12345.6789 print(f\u0026#34;{x:.2f}\u0026#34;) # 12345.68 print(format(x, \u0026#34;,.2f\u0026#34;)) # 12,345.68\rClick to expand and view more\r","title":"Python Float"},{"link":"/posts/4191130/","text":"Integer 这篇用最简单的话，讲清 Python 整数（int）：没有上限、语法好用、但有几个常见坑要注意。\n一句话认识 int int 表示整数（…，-2，-1，0，1，2，…）。 Python 的整数“没有溢出”，可以很大（自动变成大整数）。 支持二/八/十六进制字面量：0b1010（二进制）、0o12（八进制）、0xA（十六进制）。 数字下划线提高可读性：1_000_000。 常用操作（够用版） PYTHON\rCollapse\rCopy\r# 基本算术 a, b = 7, 3 print(a + b, a - b, a * b) # 10 4 21 # 除法 print(a / b) # 2.333... 真除（返回 float） print(a // b) # 2 地板除（向下取整） print(a % b) # 1 取余 # 幂与根 print(2 ** 10) # 1024 # 同时得到商和余数 print(divmod(7, 3)) # (2, 1) # 绝对值、幂函数、取整 import math print(abs(-5)) # 5 print(pow(2, 10)) # 1024（等同 **） print(math.floor(-2.3)) # -3（向下） print(math.ceil(-2.3)) # -2（向上） print(math.trunc(-2.3)) # -2（截断 toward 0）\rClick to expand and view more\r进制转换与解析 PYTHON\rCollapse\rCopy\rn = 255 print(bin(n)) # \u0026#39;0b11111111\u0026#39; 二进制字符串 print(oct(n)) # \u0026#39;0o377\u0026#39; 八进制字符串 print(hex(n)) # \u0026#39;0xff\u0026#39; 十六进制字符串 # 按指定进制解析字符串为整数 print(int(\u0026#39;1010\u0026#39;, 2)) # 10 print(int(\u0026#39;ff\u0026#39;, 16)) # 255\rClick to expand and view more\r字符串格式化（展示更友好） PYTHON\rCollapse\rCopy\rn = 1234567 print(f\u0026#39;{n:,}\u0026#39;) # \u0026#39;1,234,567\u0026#39; 千分位 print(f\u0026#39;{n:08d}\u0026#39;) # \u0026#39;01234567\u0026#39; 固定宽度，前导 0 print(f\u0026#39;{n:#x}\u0026#39;) # \u0026#39;0x12d687\u0026#39; 十六进制（带前缀） print(f\u0026#39;{n:b}\u0026#39;) # \u0026#39;100101101011010000111\u0026#39; 二进制\rClick to expand and view more\r位运算（处理标志位/掩码） PYTHON\rCollapse\rCopy\rx = 0b1010 y = 0b0110 print(x \u0026amp; y) # 0b0010 与 print(x | y) # 0b1110 或 print(x ^ y) # 0b1100 异或 print(~x) # 取反（注意补码） print(x \u0026lt;\u0026lt; 1) # 左移 1 位（乘以 2） print(x \u0026gt;\u0026gt; 1) # 右移 1 位（除以 2 向下）\rClick to expand and view more\r与布尔/浮点的关系 PYTHON\rCollapse\rCopy\rTrue == 1 # True （bool 是 int 的子类） False == 0 # True 1 + True # 2 # 与 float 混算 print(2 + 0.5) # 2.5（结果变为 float） print(5 // 2) # 2 （两个 int 地板除返回 int） print(5.0 // 2) # 2.0（涉及 float 时返回 float）\rClick to expand and view more\r容易踩雷（简明版） / 和 // 区分：/ 是真除（返回 float），// 是地板除（向下取整）。 负数的 // 是“向下取整”：-5 // 2 == -3，不是 -2。 bool 与 int：True == 1、False == 0，写计数/比较时注意可读性。 进制解析要用 int(s, base)：不要自己写解析；字符串里允许大小写、可带 0x/0b/0o。 数字字面量不能有多余前导零：012 非法（除非是 0o12 这样的进制前缀）。 位运算和布尔：True \u0026amp; True == 1，位运算返回的是 int，不是 True/False。 大整数性能：整数没有上限，但超大数的运算会变慢、占内存多；必要时换算法或近似。 身份比较陷阱：小整数可能被驻留，a is b 偶尔为真，但请始终用 == 比较内容。 速查清单 基本：+ - * / // % **、divmod(a, b)、abs(x) 取整：math.floor(x)、math.ceil(x)、math.trunc(x) 进制转换：bin(n) / oct(n) / hex(n) 解析：int(s, base)（如 int('ff', 16)） 格式化：f'{n:,}'、f'{n:08d}'、f'{n:#x}'、f'{n:b}' 位运算：\u0026amp; | ^ ~ \u0026lt;\u0026lt; \u0026gt;\u0026gt; 小示例 PYTHON\rCollapse\rCopy\r# 分支与计数 flags = [True, False, True] print(sum(flags)) # 2（True 当作 1） # 地板除与负数 print(7 // 3, -7 // 3) # 2, -3 # 掩码示例：第 3 位是否为 1 mask = 0b100 value = 0b1011 print(bool(value \u0026amp; mask)) # True # 十六进制展示 n = 4095 print(hex(n), f\u0026#39;{n:#x}\u0026#39;) # \u0026#39;0xfff\u0026#39;, \u0026#39;0xfff\u0026#39;\rClick to expand and view more\r","title":"Python Integer"},{"link":"/posts/3495985/","text":"Boolean 本文总结 Python 布尔（Boolean）类型的核心知识点、常用技术与高频用法，并梳理常见坑位与避免策略。\n核心知识点 类型与取值：bool 只有两个值：True 与 False，二者为单例。 继承关系：bool 是 int 的子类；True == 1、False == 0，参与算术运算会当作 1/0。 真值判定（Truthiness）：if x: 实际调用 bool(x)；对象可通过实现 __bool__ 或 __len__ 决定其真值。 逻辑运算符：not、and、or，具有短路特性与固定优先级（not \u0026gt; and \u0026gt; or）。 比较运算：比较表达式返回布尔；支持链式比较（如 0 \u0026lt; x \u0026lt; 10）。 单例比较：与 None 比较使用 is / is not，不要用 ==。 真值规则与常见假值 假值（bool(x) is False）常见成员：False、None、数值零（0、0.0、0j、Decimal(0)、Fraction(0, 1)）、空容器（''、[]、{}、set()、range(0)）。 真值但易误解：float('nan')、Decimal('NaN') 的布尔值为 True（容易误判为空/无效）。 非零整数（包括负数）都为 True；非空字符串（例如 '0'、'False'）也为 True。 逻辑运算与短路 PYTHON\rCollapse\rCopy\r# 优先级：not \u0026gt; and \u0026gt; or not True # False True and False # False True or False # True # 短路：左侧确定结果时，右侧不再求值 expr and f() # expr 为 False 时，f() 不执行 expr or g() # expr 为 True 时，g() 不执行 # and/or 返回“操作数”本身（非强制转 bool） 0 or \u0026#39;default\u0026#39; # \u0026#39;default\u0026#39; \u0026#39;a\u0026#39; and 123 # 123 \u0026#39;\u0026#39; and 123 # \u0026#39;\u0026#39;\rClick to expand and view more\r模式：value = x or default 常用于提供默认值；若 x 可能为合法的假值（如 0），请改用显式判断。 比较与链式比较 PYTHON\rCollapse\rCopy\rx = 5 0 \u0026lt; x \u0026lt; 10 # True，等价于 (0 \u0026lt; x) and (x \u0026lt; 10) 1 == True # True；但不建议依赖这种语义写业务逻辑 None == False # False；与 None 比较用 is/is not\rClick to expand and view more\r推荐：区间判断使用链式比较可读性更好。 类型转换与常用函数 PYTHON\rCollapse\rCopy\rbool(0) # False bool(\u0026#39;\u0026#39;) # False bool(\u0026#39;False\u0026#39;) # True（非空字符串） int(True) # 1 int(False) # 0 any([True, False, False]) # True（存在任何真值） all([True, 1, \u0026#39;x\u0026#39;]) # True（所有元素真值为真） any([]) # False all([]) # True（约定：空集的全称命题为真）\rClick to expand and view more\r解析字符串为布尔：不要直接 bool(s)；请用自定义白名单映射（如 {'1','true','yes','on'}）或第三方库。 容器与对象的真值 容器空则为 False，非空为 True：if items: 判断是否有元素。 自定义对象可实现： PYTHON\rCollapse\rCopy\rclass Box: def __init__(self, items): self.items = items def __bool__(self): return bool(self.items) # 依赖内容是否为空\rClick to expand and view more\r数值关系与统计 PYTHON\rCollapse\rCopy\rTrue + True # 2 sum([True, False, True]) # 2，统计条件成立次数的简便方式 min(True, False) # False max(True, False) # True\rClick to expand and view more\r推荐：在计数场景中以 sum(cond for ...) 统计满足条件的数量，简洁高效。 与 NumPy/Pandas 的注意事项 and/or 不能用于数组/Series 的按元素逻辑运算（会抛错或产生意外）。 使用按位运算符：\u0026amp;（与）、|（或）、~（非），并加括号： PYTHON\rCollapse\rCopy\rimport numpy as np import pandas as pd s = pd.Series([1, 2, 3]) mask = (s \u0026gt; 1) \u0026amp; (s \u0026lt; 3) # 正确 # (s \u0026gt; 1) and (s \u0026lt; 3) # 错误：ValueError\rClick to expand and view more\r聚合判断：arr.any() / arr.all()，或 cond.any() / cond.all()。 容易踩雷 bool 是 int 子类：True == 1、False == 0；避免将布尔与整数混用影响可读性。 bool('False') is True：解析字符串为布尔需自定义映射，不要用 bool(s)。 and/or 返回操作数本身：a or b 不一定是 True/False，而是 a 或 b；写条件表达式时留意此语义。 NaN 的布尔为 True：float('nan')、Decimal('NaN') 不是“空”，判断缺失要用 math.isnan/pd.isna。 与 None 比较用 is：x is None / x is not None，不要用 ==。 数组/Series 使用 \u0026amp;/|：不要用 and/or 进行按元素逻辑。 默认值模式陷阱：x or default 会把合法的假值（如 0、''）替换掉，需改用显式判断： PYTHON\rCollapse\rCopy\rvalue = x if x is not None else default\rClick to expand and view more\r常用速查 逻辑运算：not a、a and b、a or b 真值判断：if x: / if not x: 链式比较：low \u0026lt; x \u0026lt;= high 单例比较：x is None / x is not None 统计布尔：sum(flags)、any(iterable)、all(iterable) 数组逻辑：(cond1 \u0026amp; cond2) | cond3，聚合用 .any() / .all() 示例 PYTHON\rCollapse\rCopy\r# 典型条件写法 text = \u0026#39;hello\u0026#39; if text: # 非空即真 print(\u0026#39;has text\u0026#39;) # 默认值提供 port = 0 visible_port = port or 8080 # 小心：这里会得到 8080 visible_port = port if port != 0 else 8080 # 更稳妥 # 计数满足条件的元素 nums = [0, 1, 2, 3] count = sum(n % 2 == 0 for n in nums) # 偶数个数：2 # None 判断 result = None if result is None: print(\u0026#39;no result\u0026#39;) # 链式比较与短路 x = 5 if 0 \u0026lt; x \u0026lt; 10 and (x % 2 == 1): print(\u0026#39;ok\u0026#39;)\rClick to expand and view more\r","title":"Python Boolean"},{"link":"/posts/2340053/","text":"Tuple 这篇用最简单的话，讲清 Python 元组（tuple）：它是“有序、不可变、可重复”的序列，适合表示固定不变的数据、函数多返回值、字典键等场景。\n一句话认识 tuple 特性：有序、不可变（不能增删改）、允许重复、可嵌套。 单个元素的元组要加逗号：(3,)；(3) 只是数字 3。 逗号才是“元组生成符”，括号常用于可读性或解包。 元素可哈希时，tuple 本身可哈希，可做字典键。 快速上手 PYTHON\rCollapse\rCopy\r# 创建 empty = () a = (1, 2, 3) b = 1, 2, 3 # 不写括号也行（逗号决定是 tuple） single = (42,) # 单元素一定要逗号 # 访问与切片（返回新 tuple） a[0] # 1 a[-1] # 3 a[1:3] # (2, 3) # 解包与多返回值 x, y = (10, 20) print(x, y) # 10 20 # 交换变量（常见技巧） a, b = b, a # 方法（只有两个）： a.count(2) # 统计 2 的出现次数 a.index(3) # 返回 3 的首个索引 # 成员与长度 2 in a # True len(a) # 3\rClick to expand and view more\r常用命令（函数/方法） 转换：tuple(iterable)、list(t)、str(t)、sorted(t)（返回列表） 组合：a + b（拼接）、a * n（重复） 枚举/打包：enumerate(iterable)、zip(a, b)（返回由元组构成的迭代器） 方法：t.count(x)、t.index(x) 典型应用场景 多返回值/解包：函数返回多个值，外部一行解包。 字典键/集合元素：不可变且可哈希（元素也需可哈希）时可用作键。 常量表：选择用 tuple 而非 list 明确“不该被修改”。 与 list 的对比（一屏看懂） 可变性：list 可变；tuple 不可变（更安全）。 语义：tuple 表达“固定组合”；list 表达“可变集合”。 内存/性能：tuple 通常更省内存、创建更快；大量改动用 list 更合适。 容易踩雷 单元素逗号：(3,) 才是单元素元组；(3) 只是括号。 不可变≠完全不变：若内含可变对象，内部内容仍可变。 PYTHON\rCollapse\rCopy\rt = ([1, 2], 3) t[0].append(9) # 合法：修改列表，不是修改元组结构 # t[0] = [1,2,3] # 非法：试图替换元组的元素\rClick to expand and view more\rsorted(tuple) 返回列表：如需元组可再 tuple(sorted(t))。 切片返回新元组：不会影响原数据。 做字典键：只有当所有元素都可哈希时才行。 运算优先级：逗号比加法低；需要用括号确保你得到的是期望的元组。 速查清单 创建：(), (a, b), (x,), a, b（逗号决定是元组） 访问：t[i], t[a:b] 方法：count、index 运算：+ 拼接、* 重复、in 成员、len 转换：tuple(iter), list(t), sorted(t) 解包：a, b = t、a, *rest = t 小示例 PYTHON\rCollapse\rCopy\r# 1) 多返回值 def stats(nums): return min(nums), max(nums), sum(nums)/len(nums) lo, hi, avg = stats([2, 5, 9]) print(lo, hi, avg) # 2) 作为字典键（坐标） points = {(0, 0): \u0026#39;origin\u0026#39;, (1, 2): \u0026#39;p1\u0026#39;} print(points[(1, 2)]) # 3) 与 namedtuple（可读性更强） from collections import namedtuple Point = namedtuple(\u0026#39;Point\u0026#39;, [\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;]) p = Point(3, 4) print(p.x, p.y) # 3 4 # namedtuple 仍不可变，且可哈希（字段均可哈希时）\rClick to expand and view more\r","title":"Python Tuple"},{"link":"/posts/bdb4c68/","text":"Set 这篇用最简单的话，讲清 Python 集合（set）：它是“去重、无序、可变”的元素集合，适合做去重、快速包含判断与集合运算。\n一句话认识 set 特性：元素唯一、无序不可索引、可变（原地增删）。 元素必须可哈希（可作为字典键）：数字、字符串、元组可以；列表、字典不行。 空集合写法：set()（注意 {} 是空字典，不是空集合）。 不可变集合：frozenset（可做字典键）。 快速上手 PYTHON\rCollapse\rCopy\rs = {1, 2, 3} s.add(4) # {1, 2, 3, 4} s.update([3, 5]) # {1, 2, 3, 4, 5}（批量加入，自动去重） s.discard(10) # 安全删除（不存在也不报错） s.remove(2) # 删除（不存在则报错） s.pop() # 随机弹出一个元素（无序，不确定是哪一个） s.clear() # 清空\rClick to expand and view more\r常用命令（方法） 添加/批量：add(x)、update(iterable) 删除：discard(x)（安全）/ remove(x)（严格）/ pop()（弹出一个）/ clear() 查询：len(s)、x in s、x not in s 复制：s.copy()（浅拷贝） 集合运算（高频） PYTHON\rCollapse\rCopy\rA = {1, 2, 3} B = {3, 4} A | B # 并集 -\u0026gt; {1, 2, 3, 4} A \u0026amp; B # 交集 -\u0026gt; {3} A - B # 差集 -\u0026gt; {1, 2} A ^ B # 对称差 -\u0026gt; {1, 2, 4} # 对应方法 A.union(B) A.intersection(B) A.difference(B) A.symmetric_difference(B) # 子集/超集比较 A \u0026lt;= {1,2,3,4} # True（子集） A \u0026lt; {1,2,3,4} # True（真子集） A.issubset(B) # 子集判断 A.issuperset(B) # 超集判断\rClick to expand and view more\r去重与快速包含 PYTHON\rCollapse\rCopy\r# 列表去重（不保留原顺序） unique = list(set([3, 1, 2, 1, 3])) # [1, 2, 3]（顺序不保证） # 保序去重（保留出现顺序） seen = set() result = [] for x in [3, 1, 2, 1, 3]: if x not in seen: seen.add(x) result.append(x) # result -\u0026gt; [3, 1, 2] # 快速包含判断（O(1) 平均） whitelist = {\u0026#39;alice\u0026#39;, \u0026#39;bob\u0026#39;} if \u0026#39;alice\u0026#39; in whitelist: pass\rClick to expand and view more\r集合推导式（简洁写法） PYTHON\rCollapse\rCopy\rsquares = {x*x for x in range(5)} # {0, 1, 4, 9, 16} odd = {x for x in range(10) if x % 2 == 1} # 过滤保留奇数\rClick to expand and view more\r容易踩雷（简明版） {} 是空字典，不是空集合：空集合请用 set()。 无序不可索引：不能 s[0]；如需顺序，请用 list 或 sorted(s)。 pop() 弹出任意元素：不要依赖弹出的是某个具体值。 元素必须可哈希：set([1, [2,3]]) 会报错；可改用 tuple（如 set([(1,2)])）。 去重后顺序会丢失：需要保留原顺序时用“保序去重”方案（见上）。 update 和 add 区分：add(x) 加单个对象；update(iterable) 展开加入多个元素。 set 不能存可变对象作为元素（如列表），但可以存不可变集合：frozenset({...})。 速查清单 创建：set()、{...}、frozenset(iterable) 添加/批量：add / update 删除：discard / remove / pop / clear 运算：| \u0026amp; - ^、union/intersection/difference/symmetric_difference 关系：\u0026lt;= \u0026lt; \u0026gt;= \u0026gt;、issubset/issuperset 推导式：{expr for x in iterable if cond} 小示例 PYTHON\rCollapse\rCopy\rA = {1, 2, 3} B = {3, 4, 5} print(A | B) # {1, 2, 3, 4, 5} print(A \u0026amp; B) # {3} print(A - B) # {1, 2} print(A ^ B) # {1, 2, 4, 5} # 保序去重 items = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;] seen, out = set(), [] for x in items: if x not in seen: seen.add(x) out.append(x) print(out) # [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]\rClick to expand and view more\r","title":"Python Set"},{"link":"/posts/e349600/","text":"Dictionary 这篇用最简单的话，讲清 Python 字典（dict）：它是“键-值”映射，键必须可哈希（可做字典键），适合快速查找、聚合统计、配置与数据表达。\n一句话认识 dict 特性：键唯一、值可任意类型、无序（3.7+按插入顺序显示但别依赖排序）。 键必须可哈希：数字、字符串、元组可以；列表、字典不行。 常见创建：{}、dict()、dict(a=1,b=2)、dict([('a',1),('b',2)])。 快速上手 PYTHON\rCollapse\rCopy\r# 创建与访问 user = {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 20} user[\u0026#39;age\u0026#39;] # 20（不存在会报 KeyError） user.get(\u0026#39;city\u0026#39;) # None（安全访问） user.get(\u0026#39;city\u0026#39;, \u0026#39;Beijing\u0026#39;) # 默认值 # 新增与更新 user[\u0026#39;city\u0026#39;] = \u0026#39;Beijing\u0026#39; user.update({\u0026#39;age\u0026#39;: 21, \u0026#39;job\u0026#39;: \u0026#39;dev\u0026#39;}) # 删除 user.pop(\u0026#39;job\u0026#39;) # 返回值并删除 user.pop(\u0026#39;not_exist\u0026#39;, None) # 给默认值避免报错 user.popitem() # 弹出最后插入的键值对（LIFO） del user[\u0026#39;city\u0026#39;] # 查询 \u0026#39;age\u0026#39; in user # True len(user) # 键的个数 # 视图（动态） user.keys() # 所有键 user.values() # 所有值 user.items() # (键,值) 对 # 遍历（推荐） for k, v in user.items(): print(k, v)\rClick to expand and view more\r常用命令（方法） 访问：d[key]、d.get(key, default)、d.setdefault(key, default)（不存在时写入并返回）。 更新：d[key] = val、d.update(other)、合并：d1 | d2（3.9+，右侧覆盖）。 删除：d.pop(key, default)、d.popitem()、del d[key]、d.clear()。 复制：d.copy()（浅拷贝）；深拷贝用 copy.deepcopy(d)。 视图：d.keys()、d.values()、d.items()（动态反映字典变化）。 高频场景与技巧 计数： PYTHON\rCollapse\rCopy\rfrom collections import Counter Counter([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;a\u0026#39;]) # {\u0026#39;a\u0026#39;: 2, \u0026#39;b\u0026#39;: 1}\rClick to expand and view more\r分组： PYTHON\rCollapse\rCopy\rgroups = {} for x in [\u0026#39;US\u0026#39;, \u0026#39;CN\u0026#39;, \u0026#39;US\u0026#39;]: groups.setdefault(x, []).append(1) # {\u0026#39;US\u0026#39;: [1,1], \u0026#39;CN\u0026#39;: [1]}\rClick to expand and view more\r字典推导式： PYTHON\rCollapse\rCopy\rsquares = {x: x*x for x in range(5)} # {0:0, 1:1, 2:4, 3:9, 4:16}\rClick to expand and view more\r按 key/value 排序显示： PYTHON\rCollapse\rCopy\rsorted_items = sorted(user.items(), key=lambda kv: kv[0]) # 按键 sorted_by_val = sorted(user.items(), key=lambda kv: kv[1]) # 按值\rClick to expand and view more\r容易踩雷（简明版） 键重复会覆盖：{'a':1, 'a':2} -\u0026gt; {'a':2}。 键必须可哈希：d[[1,2]] = 'x' 会报错；可用元组 d[(1,2)]='x'。 边遍历边修改易出错：先 list(d.items()) 再改，或生成新字典。 popitem() 是弹出“最后插入”的项，不是随机。 浅拷贝不复制嵌套对象：copy() 只复制最外层引用，需 deepcopy。 get 默认返回 None，容易误判；可显式给默认值。 setdefault 会写入字典：仅当“需要默认结构并立即使用”时用。 视图是动态的：keys()/items() 随字典变化实时更新。 JSON 键通常要字符串：非字符串键序列化可能会不符合预期。 速查清单 创建：{}, dict(), dict(a=1), dict([(k,v)]) 访问：[], get, setdefault 更新/合并：=, update, | 删除：pop, popitem, del, clear 遍历：for k,v in d.items() 视图：keys, values, items 拷贝：copy, deepcopy 推导式：{k:v for ... if ...} 小示例 PYTHON\rCollapse\rCopy\r# 合并并保留右侧覆盖 cfg = {\u0026#39;host\u0026#39;: \u0026#39;localhost\u0026#39;, \u0026#39;port\u0026#39;: 8000} override = {\u0026#39;port\u0026#39;: 8080, \u0026#39;debug\u0026#39;: True} final = cfg | override print(final) # {\u0026#39;host\u0026#39;: \u0026#39;localhost\u0026#39;, \u0026#39;port\u0026#39;: 8080, \u0026#39;debug\u0026#39;: True} # 统计并找 Top-N from collections import Counter words = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;] print(Counter(words).most_common(2)) # [(\u0026#39;a\u0026#39;,3), (\u0026#39;b\u0026#39;,2)] # 安全读取嵌套结构 user = {\u0026#39;profile\u0026#39;: {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;}} name = user.get(\u0026#39;profile\u0026#39;, {}).get(\u0026#39;name\u0026#39;, \u0026#39;unknown\u0026#39;) print(name)\rClick to expand and view more\r","title":"Python Dictionary"},{"link":"/posts/9ffffe8/","text":"String 🎇 本文总结 Python 字符串（string）的核心知识点、常用技术与高频用法，便于查阅与速记。 核心知识点 字符串是不可变的序列类型（immutable）；支持索引与切片。 字面量：'...'、\u0026quot;...\u0026quot;、'''...'''/\u0026quot;\u0026quot;\u0026quot;...\u0026quot;\u0026quot;\u0026quot;（多行）、f\u0026quot;...\u0026quot;（f-string）、r\u0026quot;...\u0026quot;（原始字符串）。 常见转义：\\n（换行）、\\t（制表）、\\\\（反斜杠）、\\'、\\\u0026quot;。 编码与解码：str 使用 Unicode；与 bytes 通过 encode / decode 互转，常用 utf-8。 判空与 None：空串 \u0026quot;\u0026quot; 的布尔值为 False；None 表示“无值”，与空串不同。 身份 vs 相等：== 比较内容，is 比较对象身份；有时小字符串可能驻留，但不要依赖实现细节。 创建与不可变性 PYTHON\rCollapse\rCopy\rs = \u0026#39;hello\u0026#39; s[0] # \u0026#39;h\u0026#39; # s[0] = \u0026#39;H\u0026#39; # TypeError: 字符串不可变 s2 = s + \u0026#39; world\u0026#39; # 拼接 s3 = \u0026#39;ha\u0026#39; * 3 # 重复 -\u0026gt; \u0026#39;hahaha\u0026#39;\rClick to expand and view more\r频繁拼接建议使用列表累积后 ''.join(parts)，更高效。 基本操作 索引与切片：s[i]、s[start:end:step]，支持负索引与省略。 成员测试：'py' in s、'java' not in s。 长度：len(s)。 常用方法（高频） 去空白：s.strip() / s.lstrip() / s.rstrip()。 分割：s.split(sep=None, maxsplit=-1)、按行 s.splitlines()。 合并：sep.join(iterable)（例如：' '.join(words)）。 查找：s.find('x')（未找到返回 -1）、s.index('x')（未找到抛异常）。 替换：s.replace(old, new, count=-1)。 大小写：s.lower() / s.upper() / s.title() / s.capitalize() / s.swapcase()。 前后缀：s.startswith(prefix) / s.endswith(suffix)。 判断：s.isdigit() / s.isalpha() / s.isalnum() / s.isascii() / s.isspace()。 对齐/填充：s.center(width) / s.ljust(width) / s.rjust(width) / s.zfill(width)。 字符串格式化 PYTHON\rCollapse\rCopy\rname, score = \u0026#39;Alice\u0026#39;, 95 f\u0026#39;{name} 得分 {score}\u0026#39; # f-string（推荐） \u0026#39;{0} 得分 {1}\u0026#39;.format(name, score) # str.format \u0026#39;%s 得分 %d\u0026#39; % (name, score) # 旧式 % 格式（不推荐）\rClick to expand and view more\rf-string 支持表达式与格式说明：f'{x:.2f}'、f'{num:08d}'。 原始字符串与转义 原始字符串 r'...'\r不处理反斜杠转义，常用于正则：r\u0026quot;\\d+\u0026quot;。 正常字符串中需要写 \u0026quot;\\\\\u0026quot; 表示一个反斜杠。 编码与 bytes PYTHON\rCollapse\rCopy\rs = \u0026#39;你好\u0026#39; b = s.encode(\u0026#39;utf-8\u0026#39;) # bytes s2 = b.decode(\u0026#39;utf-8\u0026#39;) # str\rClick to expand and view more\r从文件/网络读取到 bytes 时，先按正确编码 decode 成 str。 正则简述（配合字符串处理） PYTHON\rCollapse\rCopy\rimport re text = \u0026#39;Order: A-123, B-456\u0026#39; re.findall(r\u0026#39;[A-Z]-\\d+\u0026#39;, text) # [\u0026#39;A-123\u0026#39;, \u0026#39;B-456\u0026#39;] re.sub(r\u0026#39;-\\d+\u0026#39;, \u0026#39;-XXX\u0026#39;, text) # \u0026#39;Order: A-XXX, B-XXX\u0026#39;\rClick to expand and view more\r简单前后缀匹配尽量用 startswith/endswith，比正则更快更清晰。 性能与技巧 构建长字符串：累积到列表，最后 ''.join(parts)。 拼接数字请显式转换或用 f-string：f'count={n}'。 处理多行文本时，用 splitlines() 和 join 管理换行。 清洗文本：先 strip() 再 split()，减少意外空项。 常用命令速查 去空白：s.strip() 分割：s.split() / s.splitlines() 合并：' '.join(items) 查找：s.find('x') / s.index('x') 替换：s.replace('a', 'b') 大小写：s.lower() / s.upper() / s.title() 判断：s.isdigit() / s.isalpha() / s.isalnum() / s.isascii() 对齐/填充：s.center(10) / s.ljust(10) / s.rjust(10) / s.zfill(5) 前后缀：s.startswith('pre') / s.endswith('suf') 代码示例 PYTHON\rCollapse\rCopy\rs = \u0026#39; Python String \u0026#39; print(len(s)) # 17 print(s.strip()) # \u0026#39;Python String\u0026#39; print(\u0026#39;Py\u0026#39; in s) # True print(s.lower()) # \u0026#39; python string \u0026#39; print(s.replace(\u0026#39; \u0026#39;, \u0026#39;-\u0026#39;)) # \u0026#39;--Python-String--\u0026#39; parts = [\u0026#39;py\u0026#39;, \u0026#39;thon\u0026#39;, \u0026#39;3\u0026#39;] print(\u0026#39;\u0026#39;.join(parts)) # \u0026#39;python3\u0026#39; name, score = \u0026#39;Alice\u0026#39;, 95 print(f\u0026#39;{name} 得分 {score:.1f}\u0026#39;) # \u0026#39;Alice 得分 95.0\u0026#39; text = \u0026#39;ID: A-12\\nID: B-34\u0026#39; print(text.splitlines()) # [\u0026#39;ID: A-12\u0026#39;, \u0026#39;ID: B-34\u0026#39;]\rClick to expand and view more\r","title":"Python String"},{"link":"/posts/54414bb/","text":"List 这篇用最简单的话，讲清 Python 列表（list）：它是有序、可变的序列，增删改查都很顺手，但有几个常见坑需要避开。\n一句话认识 list list 是有序集合，元素可重复、类型可混（不建议混用）。 可变：支持原地修改（增删改）；与 tuple（不可变）相对。 字面量：[] 空列表，[1, 2, 3]。 快速上手 PYTHON\rCollapse\rCopy\rnums = [1, 2, 3] nums[0] # 1（索引） nums[-1] # 3（倒数第一个） nums[1:3] # [2, 3]（切片） nums.append(4) # [1, 2, 3, 4]（尾部追加） nums.extend([5, 6]) # [1, 2, 3, 4, 5, 6]（批量追加） nums.insert(1, 99) # [1, 99, 2, 3, 4, 5, 6]（在索引处插入） nums.remove(99) # 删除第一个匹配值（若不存在报错） x = nums.pop() # 弹出并返回最后一个元素 nums.clear() # 清空\rClick to expand and view more\r常用方法（够用版） 添加：append(x)（单个）、extend(iterable)（多个）、insert(i, x)（在 i 处插入）。 删除：pop(i=-1)（按索引并返回）、remove(x)（按值）、clear()（清空）。 查找：index(x)（找第一个索引，未找到报错）、count(x)（计数）。 排序与方向：sort(key=None, reverse=False)（原地排序，返回 None）、reverse()（原地反转）。 复制：copy()（浅拷贝），或切片 lst[:]。 切片与拷贝 PYTHON\rCollapse\rCopy\rlst = [0, 1, 2, 3, 4] lst[1:4] # [1, 2, 3] lst[:3] # [0, 1, 2] lst[::2] # [0, 2, 4]（步长） lst[::-1] # 反转副本 # 浅拷贝：新列表，但内部引用不变 shallow = lst[:] # 或 lst.copy() # 深拷贝：连同内部对象也复制 import copy deep = copy.deepcopy(lst)\rClick to expand and view more\r浅拷贝适合扁平列表；嵌套结构需深拷贝防止共享引用。 排序与合并 PYTHON\rCollapse\rCopy\rnums = [3, 1, 2] nums.sort() # 原地排序；返回 None sorted(nums) # 返回新列表，不改原列表 # 自定义排序 words = [\u0026#39;apple\u0026#39;, \u0026#39;Banana\u0026#39;, \u0026#39;pear\u0026#39;] words.sort(key=str.lower) # 忽略大小写排序 # 合并 a = [1, 2] b = [3, 4] c = a + b # 新列表 [1,2,3,4] a.extend(b) # 原地扩展 a -\u0026gt; [1,2,3,4]\rClick to expand and view more\r记忆点：list.sort()原地修改且返回 None；sorted(list)返回新列表。 列表推导式（推荐写法） PYTHON\rCollapse\rCopy\rsquares = [x*x for x in range(5)] # [0,1,4,9,16] even = [x for x in range(10) if x % 2 == 0] # 过滤保留偶数 pairs = [(x, y) for x in range(2) for y in range(2)]\rClick to expand and view more\r用推导式替代“遍历 + append”，代码更简洁、少错。 遍历与索引 PYTHON\rCollapse\rCopy\rlst = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for item in lst: print(item) for i, item in enumerate(lst, start=1): # 从 1 开始编号 print(i, item)\rClick to expand and view more\r容易踩雷（简明版） append vs extend：append([1,2]) 会加一个“子列表”；extend([1,2]) 会把元素打散追加。 浅拷贝 vs 深拷贝：lst[:]/lst.copy() 只复制顶层；嵌套列表需要 copy.deepcopy。 乘法复制的“共享坑”：matrix = [[0]*3]*2 两行指向同一子列表，改一行另一行也变。正确：matrix = [[0]*3 for _ in range(2)]。 边遍历边删除：会跳元素或错位。正确做法：构造新列表或从后往前删，或用推导式过滤。 remove 不存在会报错：用前先判断 if x in lst:，或 try/except。 排序返回值：lst.sort() 返回 None，不要写成 lst = lst.sort()。 性能直觉：append 均摊 O(1)；insert(0, x)/在头部操作是 O(n)；大列表频繁头部插入用 collections.deque 更合适。 拼接创建新列表：a + b 生成新列表，原列表不变；大量拼接做汇总更高效的方法是一次性 extend 或推导式生成。 速查清单 添加：append / extend / insert 删除：pop / remove / clear 查找：index / count 排序：sort（原地） / sorted（新列表） / reverse 切片：lst[a:b:c] / 复制 lst[:] / 反转 lst[::-1] 推导式：[expr for x in iterable if cond] 安全拷贝：copy.deepcopy（嵌套结构） 小示例 PYTHON\rCollapse\rCopy\r# 过滤并转换 names = [\u0026#39;Alice\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39; \u0026#39;] clean = [n.strip() for n in names if n.strip()] # [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;] # 扁平化二维列表 matrix = [[1,2],[3,4]] flat = [x for row in matrix for x in row] # [1,2,3,4] # 稳妥删除 items = [1,2,3,2] items = [x for x in items if x != 2] # [1,3] # 排序 + 生成新列表 scores = [88, 92, 75] sorted_scores = sorted(scores, reverse=True) # [92, 88, 75]\rClick to expand and view more\r","title":"Python List"},{"link":"/posts/aeede5e/","text":"Vs Studio installation Install VS Studio Code\nBASH\rCollapse\rCopy\rsudo apt update Option 1 sudo apt-get install wget gpg wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor \u0026gt; packages.microsoft.gpg sudo install -D -o root -g root -m 644 packages.microsoft.gpg /etc/apt/keyrings/packages.microsoft.gpg echo \u0026#34;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main\u0026#34; |sudo tee /etc/apt/sources.list.d/vscode.list \u0026gt; /dev/null rm -f packages.microsoft.gpg sudo apt update sudo apt install code\rClick to expand and view more\r","title":"VS Studio"},{"link":"/posts/48d997b/","text":"Python Knowledge 🐍 Python 核心历史回顾（1989 ~ 2025）\r🟦 1989 ~ 1991：Python 的诞生\n👨‍💻 创始人：Guido van Rossum（吉多·范罗苏姆） 🏠 地点：荷兰阿姆斯特丹的 CWI（数学与计算机研究中心） 💡 起源：他当时想做一个更“人性化”的脚本语言，用于替代 ABC 语言（一种教育语言） 🗓️ 1991年2月：发布第一个公开版本 Python 0.9.0 🔹 名字“Python”并不是蛇，而来自英国喜剧节目 Monty Python’s Flying Circus。 🟩 1994 ~ 2000：Python 1.x 系列（ 建立基础 )\n📘 Python 1.0（1994年1月） 第一个正式稳定版本 异常机制、内置函数等 📘 Python 1.5（1998年） 新增 package 概念 奠定了 Python 模块化结构的基础 📌 关键词：模块化、简洁语法、社区初成形 🟨 2000 ~ 2008：Python 2.x 时代（黄金八年）\n📘 Python 2.0（2000年10月） 引入 垃圾回收机制（GC） 新的 列表推导式 list comprehension 新的 Unicode 支持 📌 Python 2.x 是最流行的早期版本，广泛用于 Web、科学计算、教育等领域。 📉 但因为历史遗留问题，Python 2 和 Python 3 不兼容。 🕓 Python 2.7（2010年发布）\n成为 2.x 的“最后一代”版本 原计划支持到 2015，最终延长至 2020年1月正式停止维护 🟧 2008 ~ 2020：Python 3.x 的大改革与成熟\n🧩 Python 3.0（2008年12月）\n“清理历史债务、重新设计语言基础”\n主要变化：\n🟥 print 变成函数：print(\u0026ldquo;Hello\u0026rdquo;) 🟩 默认使用 Unicode（utf-8） 🟨 整数除法：/ 返回浮点数，// 才是整除 🟦 bytes 与 str 明确区分 🟪 range() 变为惰性对象（节省内存） 📘 虽然带来了不兼容，但为未来性能和国际化打下基础。\n📗 Python 3.4 ~ 3.8（2014~2019）\n新增了许多现代特性：\nasync / await 异步语法（3.5） 类型注解（Type Hint） f-string 格式化字符串（3.6） 数据类 dataclass（3.7） 📌 Python 进入“现代化语法”阶段。\n🟥 2020 ~ 2024：Python 3.9 ~ 3.12（性能爆发期）\n重点变化：\n类型系统 大幅增强（Type Hints 完善） 结构化模式匹配（match-case）（Python 3.10） 性能提升（Python 3.11） 👉 比 Python 3.10 快 25~60% 异步 I/O、并发性能优化 内置 TOML 支持（配置管理更方便） 📘 Python 正式从“慢语言”蜕变为现代高性能语言。\n🟪 2024 ~ 2025：Python 3.13 与未来的 Python 3.14+\n🧱 Python 3.13（2024年10月）\n引入 Free-threading（自由多线程模式）实验性支持 👉 意味着未来可能真正摆脱 GIL（全局解释器锁）！ 改进 JIT 运行效率 改善启动速度与内存占用 新的 f-string 特性和标准库改进 🔮 Python 3.14（开发中）\n继续优化多线程并行 增强安全性、扩展模块编译支持 强化 typing 模块功能 Python 原理机制 类继承结构（Class Inheritance Hierarchy） 🧩 什么是「类继承结构」？ 🟦 1️⃣ **基本概念 **\n在 Python 中，类（class） 可以从另一个类 继承（inherit） 功能。\n👉 继承的意思是：\n“子类可以直接使用父类的属性和方法，而不需要重新写一遍。”\n🧠 举个简单例子： PYTHON\rCollapse\rCopy\rclass Animal: # 父类（基类） def eat(self): print(\u0026#34;动物会吃东西\u0026#34;) class Dog(Animal): # 子类（继承 Animal） def bark(self): print(\u0026#34;狗在汪汪叫\u0026#34;) dog = Dog() dog.eat() # 继承自 Animal dog.bark() # 自己的方法\rClick to expand and view more\r输出：\nTXT\rCollapse\rCopy\r动物会吃东西 狗在汪汪叫\rClick to expand and view more\r🟩 说明：\nDog 继承了 Animal 的行为（ eat() 方法 ） 如果 Dog 自己没有 eat()，就去它的父类 Animal 里找 这就是所谓的 类继承结构 🟨 2️⃣ 多层继承（层级关系）\nPython 允许多层继承，比如：\nPYTHON\rCollapse\rCopy\rclass A: pass class B(A): pass class C(B): pass\rClick to expand and view more\r📜 类继承结构（Class Hierarchy）如下：\nCSS\rCollapse\rCopy\rC → B → A → object\rClick to expand and view more\r你可以通过 base 或 mro 查看继承关系：\nPYTHON\rCollapse\rCopy\rprint(C.__mro__)\rClick to expand and view more\r输出：\nKOTLIN\rCollapse\rCopy\r(\u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;)\rClick to expand and view more\r🟧 3️⃣ 所有类的最终祖先：object\n无论你写的类多复杂，\nPython 中所有类的最顶层父类都是 object\nPYTHON\rCollapse\rCopy\rclass A: pass print(issubclass(A, object)) # True\rClick to expand and view more\r📘 这意味着：\nPython 里“一切皆对象（Everything is an object）”\n🟥 二、什么是「内置异常（Built-in Exceptions）」 这些异常其实就是一套预定义的类\n🧠 举个例子： PYTHON\rCollapse\rCopy\rprint(1 / 0)\rClick to expand and view more\r输出：\nVBNET\rCollapse\rCopy\rZeroDivisionError: division by zero\rClick to expand and view more\r📘 ZeroDivisionError 是一个类，它继承自 ArithmeticError，\n而 ArithmeticError 又继承自 Exception，\nException 再继承自 BaseException。\n这就是异常的 继承结构（就像家谱一样）。\n🧱 三、Python 内置异常的继承结构（简化版） PHP\rCollapse\rCopy\rBaseException ← 所有异常的根类 ├── SystemExit ← 程序退出（系统用） ├── KeyboardInterrupt ← 用户按 Ctrl + C ├── Exception ← 所有常规错误的父类 │ ├── ArithmeticError ← 算术错误类 │ │ ├── ZeroDivisionError ← 除以零 │ │ ├── OverflowError ← 数字太大 │ │ └── FloatingPointError ← 浮点错误 │ ├── OSError ← 操作系统错误 │ │ ├── FileNotFoundError ← 文件不存在 │ │ ├── PermissionError ← 权限不足 │ │ ├── IsADirectoryError ← 路径是目录 │ │ └── NotADirectoryError ← 非目录路径 │ ├── ValueError ← 值错误 │ ├── TypeError ← 类型错误 │ ├── KeyError ← 字典键错误 │ ├── IndexError ← 索引超出范围 │ ├── LookupError ← 查找类错误（父类） │ │ └── UnicodeDecodeError ← 解码错误 │ └── RuntimeError ← 运行时错误（通用） └── GeneratorExit ← 生成器关闭\rClick to expand and view more\r📘 注意：\n所有常见错误都在 Exception 分支下 系统级错误（例如 KeyboardInterrupt ）在 BaseException 分支下 🟩 四、如何查看一个异常的继承结构（实践） PYTHON\rCollapse\rCopy\rdef show_exception_hierarchy(err): cls = err while cls: print(\u0026#34;↳\u0026#34;, cls.__name__) cls = cls.__base__ show_exception_hierarchy(FileNotFoundError)\rClick to expand and view more\r输出：\nPHP\rCollapse\rCopy\r↳ FileNotFoundError ↳ OSError ↳ Exception ↳ BaseException ↳ object\rClick to expand and view more\r📜 这条链清楚展示了继承关系。\n🧠 五、类继承结构 和 内置异常 的关系 ✅ 本质上：\n“异常类 只是 Python 普通类体系的一部分。” 也就是说：\n异常类之间的关系 → 就是类继承结构 捕获异常时的行为 → 就依赖继承结构进行“向上匹配” 🧩 举例说明： PYTHON\rCollapse\rCopy\rtry: open(\u0026#34;不存在.txt\u0026#34;) except OSError: print(\u0026#34;OSError 捕获成功\u0026#34;) except FileNotFoundError: print(\u0026#34;FileNotFoundError 捕获成功\u0026#34;)\rClick to expand and view more\r输出：\nNGINX\rCollapse\rCopy\rOSError 捕获成功\rClick to expand and view more\r📘 原因：\nFileNotFoundError 是 OSError 的子类 Python 捕获异常时，会从上往下匹配继承链 🟨 所以顺序必须是：\nPYTHON\rCollapse\rCopy\rexcept FileNotFoundError: except OSError:\rClick to expand and view more\r👉 先捕获子类，再捕获父类！\n🎨 总结（记忆彩色卡） 概念 含义 举例 🟦 类继承结构 类之间的“血缘关系”，谁继承谁 Dog → Animal → object 🟩 内置异常 Python 自带的错误类体系 FileNotFoundError → OSError → Exception 🟨 最顶层类 所有异常的根：BaseException 捕获所有错误 🟥 最常用父类 Exception（开发者一般捕获这个） except Exception as e: 🟧 系统异常 比如 KeyboardInterrupt 不要轻易捕获 💬 一句话总结\n✅ “类继承结构是类与类之间的层次关系，\nPython 的所有异常都是一棵继承树上的节点，\n它们最终都源自 BaseException。”\nPython 语法 PYTHON\rCollapse\rCopy\rprint(\u0026#34;hello python!!!\u0026#34;)\rClick to expand and view more\r变量 a = \u0026ldquo;John\u0026rdquo;\nb = 123\nc = 3.142\nd = True\ne = [ \u0026ldquo;Superman\u0026rdquo;, \u0026ldquo;Iron-man\u0026rdquo;, \u0026ldquo;Ant-man\u0026rdquo; ]\nf = { \u0026ldquo;Price\u0026rdquo;: 50.00, \u0026ldquo;Item\u0026rdquo;: \u0026ldquo;iPhone\u0026rdquo; }\n注释\r条件判断\r数据类型\r循环 \u0026amp; 嵌套循环\r函数\r实参 \u0026amp; 形参\r异常模块\r内置函数\r类\r面向对象 This is a test\n装饰器 🧩 一、装饰器（Decorator）是什么？\n👉 装饰器本质上是一个“函数”，它的作用是给另一个函数或类添加功能，而不改动原本的代码。\n可以理解为：\n“在不改变原函数结构的前提下，给它加上一层外衣。”\n✅ 普通函数装饰器示例\nPYTHON\rCollapse\rCopy\rdef log_decorator(func): def wrapper(): print(\u0026#34;📜 正在调用函数：\u0026#34;, func.__name__) result = func() print(\u0026#34;✅ 函数执行完成\u0026#34;) return result return wrapper @log_decorator # 相当于 say_hello = log_decorator(say_hello) def say_hello(): print(\u0026#34;你好，Python！\u0026#34;) say_hello()\rClick to expand and view more\r输出结果：\nPLAINTEXT\rCollapse\rCopy\r📜 正在调用函数： say_hello\r你好，Python！\r✅ 函数执行完成\rClick to expand and view more\r","title":"Python Knowledge"},{"link":"/posts/e985480/","text":"Python Manage Extremely fast Python package and project manager, written in Rust.\nHighlight 🚀 A single tool to replace pip, pip-tools, pipx, poetry, pyenv, twine, virtualenv, and more. ⚡️ 10-100x faster than pip. 🗂️ Provides comprehensive project management, with a universal lockfile. ❇️ Runs scripts, with support for inline dependency metadata. 🐍 Installs and manages Python versions. 🛠️ Runs and installs tools published as Python packages. 🔩 Includes a pip-compatible interface for a performance boost with a familiar CLI. 🏢 Supports Cargo-style workspaces for scalable projects. 💾 Disk-space efficient, with a global cache for dependency deduplication. ⏬ Installable without Rust or Python via curl or pip. 🖥️ Supports macOS, Linux, and Windows. Installation ( Windows ) Install uv with our official standalone installer:\nPOWERSHELL\rCollapse\rCopy\rpowershell -ExecutionPolicy ByPass -c \u0026#34;irm https://astral.sh/uv/install.ps1 | iex\u0026#34;\rClick to expand and view more\rRequest a specific version by including it in the URL:\nPOWERSHELL\rCollapse\rCopy\rpowershell -ExecutionPolicy ByPass -c \u0026#34;irm https://astral.sh/uv/0.9.3/install.ps1 | iex\u0026#34;\rClick to expand and view more\rTip\rThe installation script may be inspected before use:\nPOWERSHELL\rCollapse\rCopy\rpowershell -c \u0026#34;irm https://astral.sh/uv/install.ps1 | more\u0026#34;\rClick to expand and view more\rInstallation ( Linux Ubuntu ) uv provides a standalone installer to download and install uv:\nUse curl to download the script and execute it with sh:\nBASH\rCollapse\rCopy\rcurl -LsSf https://astral.sh/uv/install.sh | sh\rClick to expand and view more\rIf your system doesn\u0026rsquo;t have curl, you can use wget:\nBASH\rCollapse\rCopy\rwget -qO- https://astral.sh/uv/install.sh | sh\rClick to expand and view more\rRequest a specific version by including it in the URL:\nBASH\rCollapse\rCopy\rcurl -LsSf https://astral.sh/uv/0.9.3/install.sh | sh\rClick to expand and view more\rTip\rThe installation script may be inspected before use:\nPOWERSHELL\rCollapse\rCopy\rcurl -LsSf https://astral.sh/uv/install.sh | less\rClick to expand and view more\r","title":"Python Manage"},{"link":"/posts/e5febaf/","text":"Python Installation 💻 Linux Ubuntu Step 1 BASH\rCollapse\rCopy\rsudo add-apt-repository ppa:deadsnakes/ppa sudo apt update sudo apt install python3.x sudo python3 --version\rClick to expand and view more\r💻 WindowsOS Step 1 a. Download python installer https://www.python.org/downloads/\rStep 2 Download \u0026amp; Install Pycharm https://www.jetbrains.com/pycharm/download/?section=windows\r","title":"Python Installation"},{"link":"/posts/460fa21/","text":"Python 3.14 关键更新（简明版） 这篇把 3.14 最重要的改动讲清楚，用最少的词和直接可跑的例子让你迅速上手：\nFree-threaded（无 GIL 选项）：支持在特定构建中移除 GIL，让多线程能真正并行跑 Python 字节码。（默认仍有 GIL 的构建） 模板字符串字面值 t\u0026quot;...\u0026quot;：更安全、更适合国际化的字符串插值语法，默认只替换标识符。 其他质量提升：解释器性能与错误信息进一步改进（细节不展开，保持高层认知）。 1. Free-threaded（无 GIL 选项） 核心点：取消全局解释器锁后，“同一进程内的多个 Python 线程”可以同时执行字节码，不再被 GIL 串行化。\n为什么重要：CPU 密集型多线程（比如计算、压缩、加密）能得到真正的并行提升；IO 密集场景依旧建议优先 asyncio 或多进程。\n当前形态：3.14 提供“有 GIL”和“无 GIL（free-threaded）”两种构建。默认仍为有 GIL版本；要尝试无 GIL，需要选择对应构建或开关。\n极简对比示例（多线程 CPU 计算）：\nPYTHON\rCollapse\rCopy\rimport time, math from concurrent.futures import ThreadPoolExecutor # 模拟 CPU 密集任务 def heavy(n): s = 0 for i in range(n): s += math.sqrt(i) return s N = 2_000_00 # 调小一点以便在本地快速测试 start = time.perf_counter() # 单线程：串行运行两次 a = heavy(N) b = heavy(N) print(\u0026#34;single:\u0026#34;, time.perf_counter() - start) start = time.perf_counter() # 多线程：两个任务并发 with ThreadPoolExecutor(max_workers=2) as ex: r = list(ex.map(heavy, [N, N])) print(\u0026#34;threads:\u0026#34;, time.perf_counter() - start)\rClick to expand and view more\r预期：\n有 GIL 构建：多线程不一定更快，可能与单线程相近（甚至更慢）。 无 GIL 构建：多线程更接近线性加速（具体提速取决于机器与任务）。 注意事项：\n扩展/原生库需要兼容 free-threaded 模式（逐步适配中）。 数据竞争与锁：无 GIL 不等于不需要锁，仍需正确使用线程同步原语（Lock,Event）。 不同构建的行为差异：团队需明确“使用的构建类型”，避免线上/线下不一致。 2. 模板字符串字面值 t\u0026quot;...\u0026quot; 核心点：t 前缀的字符串支持更安全的插值语法，默认仅替换“标识符”（变量名），避免 f-string 那样可以执行任意表达式带来的风险。\n入门例子：\nPYTHON\rCollapse\rCopy\rname = \u0026#34;Alice\u0026#34; # t-string 默认仅支持 ${identifier} 形式 msg = t\u0026#34;Hello, ${name}!\u0026#34; print(msg) # Hello, Alice!\rClick to expand and view more\r更适合哪些场景：\n国际化（i18n）：配合字典或映射进行安全替换。 配置与模板：只允许变量名插值，避免注入执行。 对比 f-string：\nPYTHON\rCollapse\rCopy\r# f-string 可以执行任意表达式（强大但有风险） x = 2 print(f\u0026#34;x^3 = {x**3}\u0026#34;) # 会计算表达式 # t-string 限制更严格，更安全，适合受控插值 user = \u0026#34;Bob\u0026#34; print(t\u0026#34;Welcome, ${user}\u0026#34;)\rClick to expand and view more\r可能的扩展：后续库可提供“自定义解析/校验”，用于更复杂的模板处理（例如从翻译表自动替换）。 3. 快速试用与迁移建议 试用 free-threaded 构建：在允许的环境中选用“无 GIL”版本进行压力测试，优先验证 CPU 密集型多线程是否得到实测收益。 评估第三方库兼容性：关键依赖（科学计算、图像处理、数据处理等）是否兼容 free-threaded 模式。 团队策略：明确“构建类型”，在 CI/CD 与发布流程中保持一致；必要时提供两套构建的基准数据供决策。 4. 容易踩雷（精简版） 误以为“无 GIL = 无锁”：并发读写仍需同步，避免数据竞争。 多线程提速不明显：任务可能是 IO 密集或受限于其他瓶颈（磁盘/网络/全局锁）。 库不兼容 free-threaded：使用前先确认依赖支持情况（官方与社区在持续适配中）。 t-string 用法误解：t 字符串默认只替换“变量名”，不执行表达式；若需要复杂插值请使用 f-string 或合适模板引擎。 5. 一屏速查 构建：3.14 同时提供“有 GIL”与“无 GIL（free-threaded）”构建（默认仍为有 GIL）。 并发选择： CPU 密集：优先尝试无 GIL + 多线程；或多进程 IO 密集：优先 asyncio 或合适的并发模型 t-string：t\u0026quot;Hello, ${name}\u0026quot; 仅变量插值，更安全，适合 i18n/模板。 f-string：强大灵活，可执行表达式；注意安全边界。 6. 如何验证你的项目在无 GIL 构建下的实际加速 明确构建类型：选择并使用 3.14 “free-threaded（无 GIL）”构建，在相同环境下对比“有 GIL”构建。 关注场景：优先测试 CPU 密集型任务（数学计算、压缩、加密、解析等）。 对比方法（线程 vs 进程）： PYTHON\rCollapse\rCopy\rimport time, math from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor def heavy(n): s = 0 for i in range(n): s += math.sqrt(i) return s N = 500_000 def bench(label, runner): start = time.perf_counter() r = runner(heavy, N) print(label, time.perf_counter() - start) return r # 单线程基线 bench(\u0026#34;single\u0026#34;, lambda fn, n: (fn(n), fn(n))) # 多线程（受 GIL 影响） bench(\u0026#34;threads\u0026#34;, lambda fn, n: ThreadPoolExecutor(2).map(fn, [n, n])) # 多进程（不受 GIL 影响，但有进程开销） bench(\u0026#34;processes\u0026#34;, lambda fn, n: ProcessPoolExecutor(2).map(fn, [n, n]))\rClick to expand and view more\r判断方式： 有 GIL：threads 通常与 single 接近或更慢。 无 GIL：threads 应明显快于 single，接近 processes（具体视任务与机器）。 注意： 扩展库兼容性：确认核心依赖在 free-threaded 模式下兼容。 并发正确性：无 GIL 不等于无锁，读写共享数据仍需同步。 统一构建类型：在 CI/CD 与生产一致，避免环境差异导致结果不同。 7. t-string 与 i18n 的工程化示例（含替换表与校验） 目标：安全插值、可校验、可回退。避免执行任意表达式，防止注入。 简易示例（t-string 直接用）： PYTHON\rCollapse\rCopy\r# 仅替换变量名（更安全） name = \u0026#34;Alice\u0026#34; print(t\u0026#34;Hello, ${name}!\u0026#34;)\rClick to expand and view more\r当模板来自外部（文件/DB），推荐“受控替换表 + 校验”的做法： PYTHON\rCollapse\rCopy\rimport re PLACEHOLDER = re.compile(r\u0026#34;\\$\\{([A-Za-z_][A-Za-z0-9_]*)\\}\u0026#34;) class TemplateError(Exception): pass def render_safe(template: str, allowed_keys: set, values: dict, fallback: dict | None = None) -\u0026gt; str: # 校验占位符只使用允许的键 keys = set(PLACEHOLDER.findall(template)) illegal = keys - allowed_keys if illegal: raise TemplateError(f\u0026#34;illegal placeholders: {sorted(illegal)}\u0026#34;) # 兜底：缺失键用 fallback 或报错 def repl(m): k = m.group(1) if k in values: return str(values[k]) if fallback and k in fallback: return str(fallback[k]) raise TemplateError(f\u0026#34;missing key: {k}\u0026#34;) return PLACEHOLDER.sub(repl, template) # 用法示例（支持 i18n） allowed = {\u0026#34;name\u0026#34;, \u0026#34;product\u0026#34;, \u0026#34;price\u0026#34;} values = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;product\u0026#34;: \u0026#34;Pro\u0026#34;, \u0026#34;price\u0026#34;: 199} cn_template = \u0026#34;亲爱的 ${name}，您订购的 ${product} 价格为 ${price} 元。\u0026#34; en_template = \u0026#34;Dear ${name}, your ${product} costs ${price} USD.\u0026#34; print(render_safe(cn_template, allowed, values)) print(render_safe(en_template, allowed, values))\rClick to expand and view more\r工程化建议： 模板存储：放置在外部资源（JSON/YAML/PO），与代码分离。 校验流程：CI 中检查模板占位符与允许的键集合一致。 回退策略：缺失键使用默认值或走“未翻译”标记，避免运行时崩溃。 不要用 f-string 渲染外部模板：防止执行表达式；统一使用受控替换器。 8. 结语 3.14 的 free-threaded 为“多线程真正并行”提供现实路径，但工程落地需评估库兼容与并发正确性。 t-string 聚焦安全插值，结合受控替换与校验可用于 i18n 的工程化场景。 ","title":"Python Update"},{"link":"/posts/81f9b3e/","text":"Github Github 安装 Github 是基于云的代码托管平台，它使用 Git 进行版本控制，帮助开发者存储、管理和共享代码\n下载 + 安装 点击此链接\rGithub 流程 :\r工作区 (Working Directory)\n位置： 就是你打开的那个 项目文件夹。你看到的所有文件，包括代码、图片、配置文件等等，都属于工作区 状态： 当你在文件中进行修改时，这些修改都处于“未追踪”或“已修改”状态 暂存区 (Staging Area / Index)\n位置： 在项目根目录下的 隐藏文件夹 .git/ 中的一个 名为 index 的文件 功能： 它充当工作区和储存区之间的“缓冲站”。你使用 git add 命令将工作区中你想要的修改精准地加入暂存区。只有被加入到暂存区的修改，才会包含在你的下一个 commit 中 储存区 (Local Repository / Git Directory)\n位置： 也是在项目 根目录下的隐藏文件夹 .git/ 中，主要内容 存储在 .git/objects 文件夹里 功能： 这是 Git 的核心数据库。当你执行 git commit 时，暂存区中的快照会被永久地记录为历史版本，并存储在储存区中 工作区 ( Working Directory ) 常用命令 git add \u0026lt; files \u0026gt; 将文件保存到暂存区 git config --global --add safe.directory 拷贝到其他设备，需要在新设备添加此配置 git tag v1.0.0 创建标签 `git commit -m`` 将暂存区文件提交到储存区 git checkout -b \u0026lt; branch \u0026gt; 如果本地没有该分支，会自动创建并跟踪对应的远程分支 git switch -c \u0026lt; branch \u0026gt; git ls - files 列出所有在 Git 仓库中被追踪的文件路径（相对于项目根目录） git rm -r --cached \u0026lt; public \u0026gt; 告诉 Git 停止追踪 public 目录中的所有文件, 但不删除本地的文件 🈯 git restore 用于撤销 工作区 和 暂存区 的更改\n✅ git restore \u0026lt; files \u0026gt; 指定工作区的文件，恢复到暂存区或上一次提交的状态 目标： 工作区 源头： 暂存区 (Staging Area) ✅ git restore --staged \u0026lt; file \u0026gt; 将文件从暂存区移回工作区，但保留你在工作区的本地修改 目标： 暂存区 ---\u0026gt; Git 会将暂存区中 的记录，恢复到 HEAD (上一次提交) 中的版本 ] 源头： 工作区 ---\u0026gt; 完全不受影响 git clone \u0026lt; http.git \u0026gt; own_directory git clone -b \u0026lt; branch \u0026gt; \u0026lt; repo_url \u0026gt; git clone -b develope --single-branch \u0026lt; 你的仓库URL \u0026gt; git log --stat 显示提交后的信息 git log -p -2 显示最新两个log信息 git log -2 显示最新两个log信息 git log --graph --oneline 以图线和一行显示 🈯 如果在错误分支下修改文件，想要将所有已经修改转移到正确的分支：\ngit stash 需要保存修改但不想提交时, 还原修改使用 git stash [ pop/apply ] git stash save \u0026quot;Solving login page issue\u0026quot; 添加一个描述，方便以后查找 git stash list 查看修改保存多个记录 git stash pop 恢复最近一次修改记录，并从列表中移除它 git stash pop stash@{2} 恢复指定的修改保存记录后，从列表中删除 git stash apply stash@{1} 恢复指定的修改保存记录，依然保留在列表中以备后用 git stash drop stash@{0} 删除指定修改保存记录 git stash clear 一次性删除所有的 git stash 修改保存记录 git clean \u0026lt; file_name \u0026gt; -f 可以删除新创建但不曾提交过的文件 git clean -n --dry-run 模拟删除不曾提交/追踪过的文件 git clean \u0026lt; folder_name \u0026gt; -nd 模拟删除不曾提交/追踪过的文件夹 git clean \u0026lt; folder_name \u0026gt; -fd 确认删除文件夹 git clean -fd 清理工作区中所有未追踪的文件 暂存区 ( Staging Area ) 常用命令 git add -p 显示确认窗口 git restore --staged \u0026lt; changed_file \u0026gt; 只从暂存区移除 git diff --staged 显示暂存区最后一次状态 git diff 比较工作文件 和 暂存区文件的差异 git diff \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt; 比较2个提交的差异 git diff --cached 查看已经 git add 但未提交的更改 git diff \u0026lt;commit\u0026gt; HEAD 查看指定提交和当前分支最新提交的差异 git diff \u0026lt;commit\u0026gt; 显示该提交与当前工作区的差异 储存区 ( Local Repository ) 常用命令 git rm 删除在储存区的文件 git mv 重命名在储存区的文件 git commit -a -m 将文件提交到储存区，跳过暂存区 git commit --amend 修改提交后的错误信息，或者遗漏添加文件（会替换原本的 commit，然后重新创建生成SHA）不建议在多人协作的共享分支上使用 🈯 git reset 撤销已经提交的命令 [ 重置历史（本地操作）]\ngit reset --hard HEAD~1 撤销最后一次的提交后，删除工作和暂存区后期的修改 git revert HEAD 不删除提交，而是生成一个“相反”的提交， git reset --soft HEAD~1 撤销上次提交，但保留工作区和暂存区的修改。\n⭕ 历史记录被重置，但你的代码文件和 git add 记录都还在。你只需重新 git commit。 git reset --mixed HEAD~1 撤销上次提交，并清除暂存区（git add 记录）。\n⭕ 历史记录被重置，本地修改保留在工作区（未暂存）。这是 git reset 的默认模式。 git reset --hard HEAD~1 彻底删除上次提交，并清除所有本地修改和暂存区。\n⭕ 这是一个毁灭性命令，本地修改会永久丢失。 🈯 git revert 不删除历史，创建新的提交，新提交内容是撤销指定提交所引入的更改\n1️⃣ 反转最新的一个提交 (HEAD)\n如果你最近提交了一个错误，但这个错误已经被推送到远程，这是最常见的用法：\nBASH\rCollapse\rCopy\rgit revert HEAD\rClick to expand and view more\r效果： 创建一个新的提交，该提交的内容是撤销当前分支上最新一次提交（HEAD）所引入的所有更改。 2️⃣ 反转指定的单个提交\n如果你想撤销历史中某个特定的、较旧的提交，你需要找到它的提交哈希（Commit Hash/ID）。\nBASH\rCollapse\rCopy\rgit revert \u0026lt; 提交 ID \u0026gt; # 示例：git revert a1b2c3d4e5f6\rClick to expand and view more\r效果： 创建一个新提交，专门用来撤销 ID 为 a1b2c3d4e5f6 的提交引入的更改。 3️⃣ 反转一系列连续的提交\n如果你想撤销从一个旧提交到最新提交之间的所有提交（但不包括最新的提交本身），可以使用范围。\nBASH\rCollapse\rCopy\rgit revert \u0026lt;旧提交 ID\u0026gt;^..HEAD # 示例：git revert b2c3d4e^..HEAD\rClick to expand and view more\r符号解释：\nb2c3d4e^ 表示提交 b2c3d4e 之前的那个提交（即从 b2c3d4e 开始）。 ..HEAD 表示到当前最新提交结束。 4️⃣ 反转但暂不提交 (-n 或 \u0026ndash;no-commit)\n如果你想将反转的更改应用到你的工作区和暂存区，但想在提交之前进行一些调整，可以使用 -n 选项。\nBASH\rCollapse\rCopy\rgit revert \u0026lt; 提交 ID \u0026gt; --no-commit\rClick to expand and view more\r效果： Git 会将反转后的代码放在你的工作区和暂存区，让你有机会检查或修改代码，然后你需要手动执行 git commit 来完成反转操作。 分支 ( Branch ) 常用命令 git branch 显示分支列表 git branch -a 显示本地 和 远程分支 git branch -r 只显示远程分支 git branch -M main 将当前分支的名称强制重命名为 main ( 用于远程空仓库，第一次在本地提交到远程仓库， 因为在本地git init 默认是master ) git branch \u0026lt; new-branch \u0026gt; 创建新分支 git branch -d \u0026lt; current-branch \u0026gt; 删除某个分支，包括master/main分支？ git branch -D \u0026lt; current-branch \u0026gt; 强制删除某个分支 git checkout -b \u0026lt; new-branch \u0026gt; 创建新分支，然后指针到新分支 git checkout \u0026lt; other-branch \u0026gt; 指针到存在的分支，也自动对应到远程分支 git merge --abort 用于merge conflict，取消合并 使用 git branch -vv 可以看到以下讯息：指针的分支，是否和远程仓库分支一样 test 5ab7ba3 [origin/test] Create a new file for result record purpose\ngit merge 将主分支 \u0026lt;\u0026mdash;- 其他分支进行文件合并\ngit chekout main/master\ngit merge [ sub-branches ]\n远程仓库 ( Remote Repository ) 常用命令 git clone 克隆github远程储存库某个项目到本地 - git pull 从远程储存库更新 ( git fetch )+ 合并 ( git merge )到本地目录 git push origin main 从本地的快照上传文件到远程储存库 ( 新分支在执行推送到远程仓库，会自动创建 ) git remote -v git remote show origin 显示当前连接的远程仓库 git remote add origin \u0026lt; git@github.com:you/project.git \u0026gt; 添加远程仓库 （ 属于自己的远程仓库 ） git remote add upstream \u0026lt; http://github.com/[git-username] \u0026gt; 添加上游 （ fork别人的github仓库 ） git remote set-url origin \u0026lt; git@github.com:you/project.git \u0026gt; 修改远程地址 git remote remove origin 删除远程仓库连接 git fetch 将远程仓库别人更新的提交，复制到本地远程分支，就可以看到别人提交什么，但不会合并\ngit log origin/main 查看main分支最新的状态\n💥 git log origin/main --online --graph 以树状显示分支状态\n💥git fetch origin optimize:optimize 本地没有该远程分支，可以直接把它 origin/optimize 拉到本地 optimize 并切换过去 git remote update 获取远程分支所有的内容，但不会自动合并到本地分支\ngit push -u origin \u0026lt; 分支名 \u0026gt; 将本地\u0026lt; 分支名 \u0026gt;分支推送代码到origin 远程仓库, -u 默认为当前的远程仓库\ngit push --set-upstream origin 等于 git push -u origin \u0026lt; branch \u0026gt;\ngit push --delete origin \u0026lt; 远程仓库分支 \u0026gt; 删除远程分支\ngit pull --rebase origin main 将其他同事推送更新，同步到本地，然后将自己的新推送放在最后\ngit log origin/master\ngit push -u origin \u0026lt; 分支名 \u0026gt; 将本地 \u0026lt; 分支名 \u0026gt; 分支推送代码到origin 远程仓库, -u 默认为当前的远程仓库\ngit push --set-upstream origin 等于 git push -u origin \u0026lt; branch \u0026gt;\ngit push --delete origin \u0026lt; 远程仓库分支 \u0026gt; 删除远程分支\ngit pull --rebase origin main 将其他同事推送更新，同步到本地，然后将自己的新推送放在最后\ngit rebase --continue\ngit merge origin/master 合并后，必须执行推送到远程仓库\ngit rebase \u0026lt; target-branch \u0026gt; 把我在其他分支提交，重新放在 main/master 后面继续排队走 MARKDOWN\rCollapse\rCopy\r[ 真实环境例子 ] main: A --- B --- C --- F \\ feature: D --- E \u0026lt;--- 我拉的分支\rClick to expand and view more\rPLAINTEXT\rCollapse\rCopy\r```markdown\r# 1. 确保在 dev 上执行 rebase 成功\rgit checkout dev\rgit rebase main # 2. 切换到 main\rgit checkout main \u0026lt;-- (这步会切换指针)\r# 3. 执行快速合并\rgit merge dev\r[ 使用 git rebase ]\rmain: A --- B --- C --- F\r\\\rfeature: D --- E \u0026lt;--- 将我分支所有提交排在main最后继续开发\rClick to expand and view more\r技巧\r💢 提交相同信息过于繁琐 方法一： 使用 git commit --amend 合并提交信息，会打开编辑器允许修改上一次提交内容\n针对同一逻辑任务的修改 + 连续多次提交的 + 还没打算推送到远程仓库 📌 Amend 工作流 1️⃣ 第一次修改并提交： BASH\rCollapse\rCopy\rgit commit -m \u0026#34;Feature: 正在开发登录模块 (WIP)\u0026#34;\rClick to expand and view more\r2️⃣ 第二次修改、第三次修改（继续在同一个任务上）： 你修改了文件，并再次 git add。然后，使用 \u0026ndash;amend 来替换上一次的提交，而不是创建一个新提交。\nBASH\rCollapse\rCopy\rgit add . git commit -a --amend --no-edit\t# 复用最后一次提交信息，跳过编辑直接完成 git commit -a --no-edit\t# 沿用上次的提交信息创建新的提交ID，创建一个全新的提交 ID，历史线性向前推进 git commit -a --amend # 替换掉上一个提交ID, 创建新提交ID, 历史被修改，发生“倒退”\rClick to expand and view more\r--amend：复用上一个提交信息，可以进行编辑 [ 销毁旧提交ID，生成新提交ID ]，\n必须使用 git push --force-with-lease 强制推送（非快进式）。 --no-edit：复用上一个提交的提交信息，跳过编辑 [ 不销毁旧提交ID，追加生成新提交ID ] 结果： 历史记录中只会保留一个提交，它包含了你所有的修改，并且提交信息是你第一次输入的那个。\n👿 后遗症： 🔍 错误原因：重写了历史 当执行 git commit --amend --no-edit 时\n你 **销毁了 **本地的旧提交 ID。 你 创建了 一个全新的、修正后的提交 ID。 你本地的 dev 分支指针指向了这个新的 ID。 然而，你的远程仓库 origin/dev 仍然指向那个 旧的提交 ID。\n当尝试 git push 时，Git 发现：\n本地 dev 指向 新 ID。 远程 dev 指向 旧 ID。 Git 无法通过简单的 快进（Fast-Forward） 方式来更新远程，因为它看起来就像你尝试用一个不相关的提交去取代远程的历史，所以它安全地拒绝了你的推送。 ✅ 解决方案：\n🚨 强制推送命令\nBASH\rCollapse\rCopy\rgit push origin dev --force\rClick to expand and view more\r或者使用更安全的版本：\nBASH\rCollapse\rCopy\rgit push origin dev --force-with-lease\rClick to expand and view more\r为什么推荐 --force-with-lease？\n--force：会无条件覆盖远程分支的历史。如果你的队友在你修正历史期间向远程推送了新的提交，--force 会默默地删除掉你队友的提交！ --force-with-lease：这是更安全的选择。它只会在远程分支在你上次拉取或推送之后 没有发生变化 的情况下才执行强制推送。如果远程在你不知情的情况下被更新了，它会拒绝推送，从而保护你队友的工作。 🧰 其他设备 git pull 方式' 方案一：如果本地分支上没有未推送的工作（最常见情况） 如果只是让本地分支完全匹配远程的新历史，这是最简单的方法：\nBASH\rCollapse\rCopy\rgit fetch # 获取远程的所有新历史，但不合并或修改本地分支 git reset --hard origin/\u0026lt;分支名\u0026gt; # 强制将本地分支指针和工作目录重置为远程的最新状态 Click to expand and view more\r解释： git fetch 拿到新的历史（即 A'），然后 git reset --hard 丢弃本地旧的 A，直接指向并采用 A'\n方案二：如果本地分支上有基于旧提交的未推送工作 如果他们在你 amend 之前，基于旧的提交 A 已经创建了新的提交 B，那么他们需要将这个本地工作 B 重新应用到新的远程提交 A' 之上\nBASH\rCollapse\rCopy\rgit fetch # 获取远程的新历史 A\u0026#39; git rebase origin/\u0026lt;分支名\u0026gt; # 将本地的未推送提交（如 B） # 重新应用到远程分支的新历史（A\u0026#39;）之上\rClick to expand and view more\r解释： git rebase 会将他们的本地提交（B）“剪切”下来，然后将新的远程历史（A'）“粘贴”在前面，再将本地提交（B）“重新应用”上去，最终历史变为 A' -\u0026gt; B'。\n其难杂症\r💢 在第二台设备使用 git pull origin dev 子分支，成功拉取但是文件不是最新版本 🔍 原因一：你当前不在 dev 分支上 尽管你执行了 git pull origin dev，但 Git 默认是将远程的 origin/dev 拉取到你的 本地 dev 分支。如果你的工作区当前检出的是 main 或其他分支，那么你眼前的代码就不会变动。\n解决办法：确认和切换分支 1️⃣ 检查当前分支：\nBASH\rCollapse\rCopy\rgit branch\t#（当前分支前会有一个 * 号。）\rClick to expand and view more\r2️⃣ 切换到 dev 分支：\nBASH\rCollapse\rCopy\rgit checkout dev\rClick to expand and view more\r3️⃣ 再次拉取（确保万无一失）：\nBASH\rCollapse\rCopy\rgit pull origin dev\rClick to expand and view more\r🔍 原因二：pull 时的本地合并问题 \u0026raquo; git pull 实际上是两个命令的组合：git fetch（拉取远程数据）和 git merge（将拉取到的数据合并到当前分支）。\n解决办法：清理并强制更新 1️⃣ 检查工作区状态：\nBASH\rCollapse\rCopy\rgit status\t# （查看是否有未提交的更改或冲突。）\rClick to expand and view more\r2️⃣ 强制重置： 如果你确定本地的更改不重要，你想让本地分支完全匹配远程分支，可以使用 reset 命令将本地 dev 强制重置到远程的最新状态。\nBASH\rCollapse\rCopy\r# 切换到 dev 分支 git checkout dev # 强制丢弃本地所有更改，并将本地分支指针指向远程分支的最新提交 git reset --hard origin/dev git stash ⚠️ 注意： git reset --hard 会永久丢弃你在本地 dev 上所有未提交或未推送的更改。\u0026gt;\u0026gt; 请确保你真的不需要这些更改。\rClick to expand and view more\r🔍 原因三：Untracked 或 Ignored 文件干扰 如果你在项目中使用构建工具，一些旧的编译产物或缓存文件可能仍然存在于你的工作区，并让你误以为代码不是最新的。\n解决办法：清理工作区 1️⃣ 执行 Dry Run 检查 (强烈推荐)：\nBASH\rCollapse\rCopy\rgit clean -nfd\t# （查看哪些文件会被删除。）\rClick to expand and view more\r2️⃣ 执行清理：\nBASH\rCollapse\rCopy\rgit clean -fd\t# （-f 强制执行，-d 删除未追踪的文件夹。）（-f 强制执行，-d 删除未追踪的文件夹。）\rClick to expand and view more\r","title":"Github"},{"link":"/posts/1d93d80/","text":"Resume Goh Ting Kang  (+6010)939-9688  tkgoh228@gmail.com  chris\r Introduction I am a dedicated technologu emthusiast with 10 years in IT Support. I continuously seek out and explore new tech to enhance my skills. My greatest fulfillment comes from turning what I learn into tangible value and enjoying the sense of accomplishment.\n Certifications Microsoft Azure Fundamentals 07 May 2022 Microsoft Certified Solutions Associate: Windows Server 2016 13 Oct 2020 Microsoft Certified Solutions Associate: Windows Server 2012 23 Jan 2020 MTA Windows Server Administration Fundamentals 22 Dec 2018 Google Google AI Essentials 23 Jul 2025 Google IT Automation with Python 27 Jul 2025 Google IT Support 14 May 2022  Work Experience IT Support Engineer - UNITED CAPS Kulim Sdn Bhd February 2023 - Present\nInternally Management\nSupport daily technical end to end user including hardware, software Manage group ticket of user in Jira Ticket Management System comply with IT Compliance, Policies and Audit Apply IT Compliance, Policies and Audit accordingly by Group IT Python automate monthly report and analysis of user ticket for discussion with HOD Provide user training at appropriate level Co-laboration with local IT Supplier and Vendor for IT equipment purchase, projects and repairing Using VCS (Version Control System) to manage projects \u0026amp; scripts Services Management\nManage IT asset management with SnipeIT Co-laboration with IT team to deployment such as Fortigate Firewall, Microsoft Intune, Google Workspace, Microsoft365, and other IT infrastructure Manage Sharepoint Online site and document Manage Zoom license and user account Integrade collaborative documentation and knowledge management in Jira Confluence Project Tasks\nProject assist ERP Odoo system implementation and provide frontline maintenance for new and existing IT initiatives Senior Executive IT Engineer - Straits Orthopaedics (Mfg) Sdn Bhd August 2022 - January 2023\nInternally Management\nTo ensure the stability, integrity, and efficient operation of the IT services that support core company functions. Responsible for IT infrastructure and security area including but not limited to server, network, virtualization, storage, software license, server room, email service and firewall. Support day to day L2 \u0026amp; L1 IT operations that ensure IT service availability Monitor and respond effectively to issues received via IT ticketing system. Monitor IT service regularly and coordinate scheduled maintenance Perform administrative works on networking, security and backup. Make sure all systems are compliant with IT policy. Maintain and troubleshoot IT devices/equipment such as a computer, printer, phone, switches, routers and Wifi AP. Create add printer GUI tool for user to reduce IT time cost and improve user experience Create ISO with installed software to consistent system versions to reduce time of manually install Junior Executive IT Engineer - Hongrita Precision Component (M) Sdn Bhd April 2022 - July 2022\nInternally Management\nCreate IT compliance and SOP provide training to end users Reform software licensing issue due to unauthorized license meanwhile provide a brief to management Propose and explain to management backup solution scheme 3-2-1 Network cabling point to point assigned by HOD Support user in systems, applications, and products SAP with HQ SAP team to schedule training to user when needed example module modify, procedure flow amended, new module added and so on Manage Active directory forest server 2019, AD users in Malaysia branch and DHCP Manage enterprise user email domain ( configure account on users PC/Android/iOS, create email, reset password, auto reply out of office, signature ) Group IT Support - Goh Siong Tee Sdn Bhd\rFebruary 2017 - March 2022\nInternally Management\nHandled plant CCTV, alarm system, door access system Monitor all servers data backup run smooth on schedule Provide technical support and training to end users Managed Video Conference System Managed Software Licensing and Maintenance Contacts such as Office365, Windows OS, Autocount Services, SAP Services, POS Services Liaise with Vendor, Supplier for IT equipment purchase and new projects implement Services Management\nCollaboration with Support Team of SAP, Autocount, POS System, Attendance Fingerprint, PABX System and CCTV \u0026amp; Alarm System\nCollaboration with third parties to deploy new project for new business landing Monitor and ensure all server data backup run smooth on schedule\nManage Office 365, Sohpos/Watchguard firewall, Sophos Intercept X license and Synology C2 Cloud Storage\nCompile batch script to automate daily backup and improve security of server transform backup from on premise to Synology Cloud Storage\nDeployed WDS to install windows operating system through PXE network\nImplemented WFH thru firewall VPN for all office users to maintain organazation operation when government announced first 18 March 2020\nProject Tasks\nAssisted Management team to setup POS Client System, Workstation, Network Cabling, CCTV \u0026amp; Alarm System new business retails shop landing Assisted Management team to setup new company Green Island Feed Mills Sdn Bhd landing Co-laboration with ERP team (China) to implementation Farm Tracking System  Projects Hugo Blog hugo.maplescraps.com\rBuiled personal blog for learning\nLanguage: Go, Toml, Yaml Database: Markdown Online Platform: Github, Netlify Subscript Tool\rsubscript-tool.vercel.app\rDeveloped a web application to manage personal monthly subscription\nfrontend tech: HTML5, CSS3, JavaScript backend tech: Firebase Online Platform: Github, Vercel Equip Tracker equip-info-six.vercel.app\rDeveloped a web application to manage products warranty and informations\nfrontend tech: HTML, CSS, JavaScript backend tech: Firebase Online Platform: Github, Vercel Password Manager info-manage.maplescraps.com/\rBuilding password manager tool for mamage family password\nFrontend: React, Vite Language: HTML, CSS, JavaScript Database: Firebase Authentication: Google Online Platform: Github, Vercel Technical: Node.js  Skills Software \u0026amp; Programming: Python, Bash, Powershell IT Infrastructure \u0026amp; Cloud: Cloud Platforms (AWS, Azure, GCP), virtualization Containerization \u0026amp; Orchestration: docker, docker compose, k8s Generative AI: OpenAI, Claude, Deepseek, Grok, Perplexity, Gemini AI/ML Frameworks: Cursor AI, Windsurf AI, Trae AI ","title":"Resume"},{"link":"/posts/1d93d80/","text":"Resume Goh Ting Kang  (+6010)939-9688  tkgoh228@gmail.com  chris\r Introduction I am a dedicated technologu emthusiast with 10 years in IT Support. I continuously seek out and explore new tech to enhance my skills. My greatest fulfillment comes from turning what I learn into tangible value and enjoying the sense of accomplishment.\n Certifications Microsoft Azure Fundamentals 07 May 2022 Microsoft Certified Solutions Associate: Windows Server 2016 13 Oct 2020 Microsoft Certified Solutions Associate: Windows Server 2012 23 Jan 2020 MTA Windows Server Administration Fundamentals 22 Dec 2018 Google Google AI Essentials 23 Jul 2025 Google IT Automation with Python 27 Jul 2025 Google IT Support 14 May 2022  Work Experience IT Support Engineer - UNITED CAPS Kulim Sdn Bhd February 2023 - Present\nInternally Management\nSupport daily technical end to end user including hardware, software Manage group ticket of user in Jira Ticket Management System comply with IT Compliance, Policies and Audit Apply IT Compliance, Policies and Audit accordingly by Group IT Python automate monthly report and analysis of user ticket for discussion with HOD Provide user training at appropriate level Co-laboration with local IT Supplier and Vendor for IT equipment purchase, projects and repairing Using VCS (Version Control System) to manage projects \u0026amp; scripts Services Management\nManage IT asset management with SnipeIT Co-laboration with IT team to deployment such as Fortigate Firewall, Microsoft Intune, Google Workspace, Microsoft365, and other IT infrastructure Manage Sharepoint Online site and document Manage Zoom license and user account Integrade collaborative documentation and knowledge management in Jira Confluence Project Tasks\nProject assist ERP Odoo system implementation and provide frontline maintenance for new and existing IT initiatives Senior Executive IT Engineer - Straits Orthopaedics (Mfg) Sdn Bhd August 2022 - January 2023\nInternally Management\nTo ensure the stability, integrity, and efficient operation of the IT services that support core company functions. Responsible for IT infrastructure and security area including but not limited to server, network, virtualization, storage, software license, server room, email service and firewall. Support day to day L2 \u0026amp; L1 IT operations that ensure IT service availability Monitor and respond effectively to issues received via IT ticketing system. Monitor IT service regularly and coordinate scheduled maintenance Perform administrative works on networking, security and backup. Make sure all systems are compliant with IT policy. Maintain and troubleshoot IT devices/equipment such as a computer, printer, phone, switches, routers and Wifi AP. Create add printer GUI tool for user to reduce IT time cost and improve user experience Create ISO with installed software to consistent system versions to reduce time of manually install Junior Executive IT Engineer - Hongrita Precision Component (M) Sdn Bhd April 2022 - July 2022\nInternally Management\nCreate IT compliance and SOP provide training to end users Reform software licensing issue due to unauthorized license meanwhile provide a brief to management Propose and explain to management backup solution scheme 3-2-1 Network cabling point to point assigned by HOD Support user in systems, applications, and products SAP with HQ SAP team to schedule training to user when needed example module modify, procedure flow amended, new module added and so on Manage Active directory forest server 2019, AD users in Malaysia branch and DHCP Manage enterprise user email domain ( configure account on users PC/Android/iOS, create email, reset password, auto reply out of office, signature ) Group IT Support - Goh Siong Tee Sdn Bhd\rFebruary 2017 - March 2022\nInternally Management\nHandled plant CCTV, alarm system, door access system Monitor all servers data backup run smooth on schedule Provide technical support and training to end users Managed Video Conference System Managed Software Licensing and Maintenance Contacts such as Office365, Windows OS, Autocount Services, SAP Services, POS Services Liaise with Vendor, Supplier for IT equipment purchase and new projects implement Services Management\nCollaboration with Support Team of SAP, Autocount, POS System, Attendance Fingerprint, PABX System and CCTV \u0026amp; Alarm System\nCollaboration with third parties to deploy new project for new business landing Monitor and ensure all server data backup run smooth on schedule\nManage Office 365, Sohpos/Watchguard firewall, Sophos Intercept X license and Synology C2 Cloud Storage\nCompile batch script to automate daily backup and improve security of server transform backup from on premise to Synology Cloud Storage\nDeployed WDS to install windows operating system through PXE network\nImplemented WFH thru firewall VPN for all office users to maintain organazation operation when government announced first 18 March 2020\nProject Tasks\nAssisted Management team to setup POS Client System, Workstation, Network Cabling, CCTV \u0026amp; Alarm System new business retails shop landing Assisted Management team to setup new company Green Island Feed Mills Sdn Bhd landing Co-laboration with ERP team (China) to implementation Farm Tracking System  Projects Hugo Blog hugo.maplescraps.com\rBuiled personal blog for learning\nLanguage: Go, Toml, Yaml Database: Markdown Online Platform: Github, Netlify Subscript Tool\rsubscript-tool.vercel.app\rDeveloped a web application to manage personal monthly subscription\nfrontend tech: HTML5, CSS3, JavaScript backend tech: Firebase Online Platform: Github, Vercel Equip Tracker equip-info-six.vercel.app\rDeveloped a web application to manage products warranty and informations\nfrontend tech: HTML, CSS, JavaScript backend tech: Firebase Online Platform: Github, Vercel Password Manager info-manage.maplescraps.com/\rBuilding password manager tool for mamage family password\nFrontend: React, Vite Language: HTML, CSS, JavaScript Database: Firebase Authentication: Google Online Platform: Github, Vercel Technical: Node.js  Skills Proficient in multiple programming languages, including Octolang, OctoScript, and more, with a strong grasp of object-oriented and functional programming paradigms. Excellent communication and collaboration skills, both with octopuses and fellow cats. Solid understanding of software development principles, data structures, and algorithms, with a focus on writing clean, efficient, and maintainable code. Extensive experience with Git version control, including strategies such as GitFlow and GitHub Flow. ","title":"Resume"},{"link":"/posts/560e275/","text":"Hugo_syntax hugo 语法库:\rShortcode 语法结构 {{\u0026lt; \u0026hellip; \u0026gt;}} (尖括号): 用于 Shortcode 结果不会被 Markdown 处理器再次处理的情况，通常用于插入复杂的 HTML 结构，比\u0026gt; 如\u0026gt; 图片 (figure) 或卡片。 {{% \u0026hellip; %}} (百分号): 用于 Shortcode 结果需要被 Markdown 处理器再次处理的情况。由于 \u0026gt; {{% param \u0026quot;\u0026quot; %}} 的结果通常是文本（如 \u0026ldquo;red\u0026rdquo;），Markdown 处理器需要能够将这段文本作为普通内容的一部分来渲染，因此必\u0026gt; 须使用百分号版本。 Picture Shortcode\r在markdown文章中嵌入此 shortcode, 就可以实现了\nExample {{\u0026lt; figure \u0026hellip; \u0026gt;}}: 插入图片或视频，支持 caption、link 等参数。 {{\u0026lt; figure src=\u0026quot;/images/xxx.jpg\u0026quot; alt=\u0026ldquo;xxx\u0026rdquo; caption=\u0026ldquo;xxx\u0026rdquo; link=\u0026ldquo;https://xxx\u0026rdquo; class=\u0026ldquo;w-75 ma0\u0026rdquo; \u0026gt;}} 示例 : Image description\nInstagram shortcode\r在markdown文章中嵌入此 shortcode, 就可以实现了\nExample To display an Instagram post with this URL:\nhttps://www.instagram.com/p/CxOWiQNP2MO/\nInclude this in your Markdown:\n{{\u0026lt; instagram CxOWiQNP2MO \u0026gt;}}\nYouTube shortcode\r在markdown文章中嵌入此 shortcode, 就可以实现了\nExample To display an Instagram post with this URL:\nhttps://www.youtube.com/watch?v=0RKpf3rK57I\nInclude this in your Markdown:\nHightLight shortcode\r在markdown文章中嵌入此 shortcode, 就可以实现了\nExample 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 for i := 0; i \u0026lt; 3; i++ { 7 fmt.Println(\u0026#34;Value of i:\u0026#34;, i) 8 } 9} 10\u0026gt;\u0026gt;\rYou can also use the highlight shortcode for inline code snippets: This is some fmt.Println(\u0026#34;inline\u0026#34;) code.\n{{\u0026lt; highlight go \u0026ldquo;hl_inline=true\u0026rdquo; \u0026gt;}} Your_text_highlight {{\u0026lt; /highlight \u0026gt;}}\nQR shortcode\r在markdown文章中嵌入此 shortcode, 就可以实现了\nExample Use the self-closing syntax to pass the text as an argument:\nOr insert the text between the opening and closing tags:\nTo create a QR code containing contact information in the vCard format:\n","title":"Hugo_syntax"},{"link":"/posts/a96565a/","text":"AI Prompt 所有的提示词样式会不断更新, 只作为参考。一切为实际测试结果为准\nChatGPT\rDeepseek\rGemini\rGrok\r","title":"AI Prompt"},{"link":"/posts/f8626cb/","text":"GitHub 风格提示框 Note\r这是一个注意提示框。用于显示用户应该注意的有用信息，即使在快速浏览内容时也应该注意。\nTip\r这是一个提示提示框。提供有助于更好或更轻松地完成任务的建议。\nImportant\r这是一个重要提示框。显示用户成功完成任务所需的关键信息。\nWarning\r这是一个警告提示框。由于潜在风险，需要用户立即注意的关键内容。\nCaution\r这是一个注意提示框。建议采取行动以避免负面后果。\n可折叠笔记框 可折叠提示框\r这是一个可折叠的注意提示框。点击标题可以展开或折叠内容。 这里可以包含更多详细信息，当用户需要时可以展开查看。\n高级使用技巧\r这个折叠的提示框包含高级使用技巧：\n首先做这个 然后做那个 最后完成这个步骤 记住要按顺序执行这些步骤。\n重要配置信息\r这些配置设置对系统正常运行至关重要：\nYAML\rCollapse\rCopy\rserver: port: 8080 host: localhost database: url: mongodb://localhost:27017 name: myapp\rClick to expand and view more\r请确保所有设置都正确配置。\n安全警告\r在继续之前，请注意以下安全考虑：\n确保所有密码都是强密码 启用双因素认证 定期更新系统 不要在公共网络上执行敏感操作 复杂内容示例\r这个可折叠框包含复杂的 Markdown 内容：\n子标题 这是一个包含链接\r和其他格式的段落。\nJAVASCRIPT\rCollapse\rCopy\r// 代码块示例 function hello() { console.log(\u0026#34;你好，世界！\u0026#34;); }\rClick to expand and view more\r表格 示例 行1 数据1 行2 数据2 普通引用块 这是一个普通的引用块，不是提示框：\n这是一个标准的引用块。它不会被渲染为提示框，而是使用标准的引用块样式。\n支持多行内容和格式化文本。\n多语言支持 提示框支持多种语言，标题会自动以当前语言显示：\nNote\r在中文环境中，这个标题会显示为\u0026quot;注意\u0026quot;。\nTip\r在中文环境中，这个标题会显示为\u0026quot;提示\u0026quot;。\n嵌套内容测试 嵌套内容测试\r这个提示框包含嵌套内容：\n这是一个嵌套的引用块\n列表项 嵌套列表项 另一个嵌套项 有序列表 嵌套有序列表 另一个嵌套项 最佳实践 性能优化建议\r为了获得最佳性能，建议：\n使用 CDN 加速静态资源 启用 gzip 压缩 优化图片大小 使用浏览器缓存 重要配置 Important\r修改配置文件后，必须重启服务才能生效。\n安全提醒 Warning\r请勿在生产环境中使用默认密码。\n破坏性操作 Caution\r此操作将永久删除所有数据，且无法恢复。请确保已备份重要数据。\n这些提示框可以帮助用户更好地理解内容的重要性和上下文，提升文档的可读性和用户体验。\nInstagram shortcode Example To display an Instagram post with this URL:\nHTML\rCollapse\rCopy\rhttps://www.instagram.com/p/CxOWiQNP2MO/`\rClick to expand and view more\rInclude this in your Markdown:\nMARKDOWN\rCollapse\rCopy\r{{\u0026lt; instagram CxOWiQNP2MO \u0026gt;}}\rClick to expand and view more\rThe rendered output will be: View this post on Instagram Highlight shortcode To highlight shortcode takes three arguments. MARKDOWN\rCollapse\rCopy\r{{\u0026lt; highlight LANG OPTIONS \u0026gt;}} CODE {{\u0026lt; /highlight \u0026gt;}}\rClick to expand and view more\rExample MARKDOWN\rCollapse\rCopy\r{{\u0026lt; highlight go \u0026#34;linenos=inline, hl_lines=3 6-8, style=emacs\u0026#34; \u0026gt;}} package main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt; 3; i++ { fmt.Println(\u0026#34;Value of i:\u0026#34;, i) } } {{\u0026lt; /highlight \u0026gt;}}\rClick to expand and view more\rHugo render this to: 1\u0026gt; package main 2\u0026gt; 3\u0026gt; import \u0026#34;fmt\u0026#34; 4\u0026gt; 5\u0026gt; func main() { 6\u0026gt; for i := 0; i \u0026lt; 3; i++ { 7\u0026gt; fmt.Println(\u0026#34;Value of i:\u0026#34;, i) 8\u0026gt; } 9\u0026gt; } 10\u0026gt; You can also use the highlight shortcode for inline code snippets: MARKDOWN\rCollapse\rCopy\rThis is some {{\u0026lt; highlight go \u0026#34;hl_inline=true\u0026#34; \u0026gt;}}fmt.Println(\u0026#34;inline\u0026#34;){{\u0026lt; /highlight \u0026gt;}} code.\rClick to expand and view more\rHugo render this to: This is some fmt.Println(\u0026#34;inline\u0026#34;) code.\n","title":"Hugo_knowledge"},{"link":"/posts/3fadbfd/","text":"Hugo 这是一篇关于Hugo博客的技术文章，主要介绍Hugo的使用方法和配置\n知识点:\r博客根目录 指的是在博客文件夹内, 包含所有博客文章、配置文件、主题文件等 .yaml 和 .toml 都是配置文件格式, 用于配置博客的参数和外观, 推荐使用 .toml 格式, 因为它更简洁和易读 第一步 前提条件\r在还没开始配置Hugo之前，确保已经安装以下的软件:\nGo\rGit\r第二步 下载 最新版本Hugo \u0026amp; Hugo主题:\nHugo\r( 目前最新版本 \u0026gt;= v0.150.1 ) Hugo 主题\r( 本人使用hugo-narrow ) 第三步 选择你想要保存的路径, 点击右键 -\u0026gt; 选择Open Git Bash here,新建一个文件夹, 用于存放Hugo博客的文件 GIT\rCollapse\rCopy\rmkdir C:\\\u0026lt;blog_name\u0026gt;\rexample:\rmkdir C:\\hugo\rClick to expand and view more\r第四步 进入已经创建的文件夹 GIT\rCollapse\rCopy\rcd C:\\hugo\rClick to expand and view more\r第五步 初始化Hugo博客 GIT\rCollapse\rCopy\rhugo new site .\rClick to expand and view more\r第六步 下载 hugo-narrow 主题\nGIT\rCollapse\rCopy\rgit submodule add https://github.com/hugo-narrow/hugo-narrow.git themes/hugo-narrow\rClick to expand and view more\r第七步 配置 hugo-narrow 主题\nGIT\rCollapse\rCopy\r# 跳转到下载好的hugo-narrow主题的exampleSite文件夹, 复制hugo.yaml文件到hugo_blog文件夹\rcp C:\\hugo\\hugo_blog\\themes\\hugo-narrow\\exampleSite\\hugo.yaml .\\hugo.yaml\rClick to expand and view more\r第八步 转换 .yaml 语法为 .toml: yaml to toml\r编辑 hugo.yaml 文件, 拷贝粘贴转换好的.toml语法, 替换原有的.yaml语法 删除根目录下原本的 hugo.toml / hugo.yaml 文件 重命名 hugo.yaml 为 hugo.toml 第九步 启动 hugo 服务\nhugo server ( 默认端口为 1313 ) 打开浏览器, 访问 http://localhost:1313/ 查看Hugo博客的效果 如果需要指定端口号, 可以在启动命令中添加 -p \u0026lt;port\u0026gt; 参数 例如: hugo server -p 8080 然后在浏览器中访问 http://localhost:8080/ ","title":"Hugo"},{"link":"/posts/40c875a/","text":"Vietnam_trip 引言 分享一些生活中的感悟和思考\u0026hellip;\n主要内容 ","title":"Vietnam_trip"}],"tags":[{"link":"/tags/devops/","name":"DevOps","slug":"DevOps"},{"link":"/tags/knowledge/","name":"Knowledge","slug":"Knowledge"},{"link":"/tags/%E5%8D%9A%E5%AE%A2/","name":"博客","slug":"博客"},{"link":"/tags/%E5%BC%80%E5%8F%91/","name":"开发","slug":"开发"},{"link":"/tags/%E6%84%9F%E6%82%9F/","name":"感悟","slug":"感悟"},{"link":"/tags/%E6%8A%80%E6%9C%AF/","name":"技术","slug":"技术"},{"link":"/tags/%E7%94%9F%E6%B4%BB/","name":"生活","slug":"生活"},{"link":"/tags/%E8%BF%90%E7%BB%B4/","name":"运维","slug":"运维"}]}